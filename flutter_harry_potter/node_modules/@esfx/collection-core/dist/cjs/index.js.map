{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts","../../../../internal/guards/dist/cjs/index.js"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;EAcE;;;AAcF,IAAiB,iBAAiB,CAmBjC;AAnBD,WAAiB,iBAAiB;IAC9B,+BAA+B;IAE/B;;OAEG;IACU,qBAAG,GAAG,MAAM,CAAC,GAAG,CAAC,8CAA8C,CAAC,CAAC;IAE9E,kCAAkC;IAErB,sBAAI,GAAG,mBAAmB,CAAC;IAExC;;OAEG;IACH,SAAgB,WAAW,CAAC,KAAU;QAClC,OAAO,CCdJ,YAAY,KAAK,QDetB,IAAM,UCfsC,IDe1B,ICdb,YAAY,KAAK,UDkBzB,KAJY,iBAAiB,CAAC,GAAG,IAAI,KAAK,CAAC;IAC1C,CAAC;IAHe,6BAAW,cAG1B,CAAA;AACL,CAAC,EAnBgB,iBAAiB,GAAjB,yBAAiB,KAAjB,yBAAiB,QAmBjC;AAkBD,IAAiB,SAAS,CA2BzB;AA3BD,WAAiB,SAAS;IACtB,+BAA+B;IAEjB,aAAG,GAAG,iBAAiB,CAAC,GAAG,CAAC;IAE1C,kCAAkC;IAElC,uBAAuB;IAEvB;;OAEG;IACU,aAAG,GAAG,MAAM,CAAC,GAAG,CAAC,sCAAsC,CAAC,CAAC;IACtE,SAAS,CAAC,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,yCAAyC,CAA4B,CAAC;IAEpG,2BAA2B;IAEd,cAAI,GAAG,WAAW,CAAC;IAEhC;;OAEG;IACH,SAAgB,WAAW,CAAC,KAAU;QAClC,OAAO,iBAAiB,CAAC,WAAW,CAAC,KAAK,CAAC;eACpC,SAAS,CAAC,GAAG,IAAI,KAAK;eACtB,SAAS,CAAC,MAAM,IAAI,KAAK,CAAC;IACrC,CAAC;IAJe,qBAAW,cAI1B,CAAA;AACL,CAAC,EA3BgB,SAAS,GAAT,iBAAS,KAAT,iBAAS,QA2BzB;AAqBD,IAAiB,kBAAkB,CAkClC;AAlCD,WAAiB,kBAAkB;IAC/B,+BAA+B;IAEjB,sBAAG,GAAG,iBAAiB,CAAC,GAAG,CAAC;IAE1C,kCAAkC;IAElC,gCAAgC;IAEhC;;OAEG;IACU,uBAAI,GAAG,MAAM,CAAC,GAAG,CAAC,+CAA+C,CAAC,CAAC;IAEhF,mCAAmC;IAEtB,uBAAI,GAAG,oBAAoB,CAAC;IAUzC;;OAEG;IACH,SAAgB,WAAW,CAAC,KAAU;QAClC,OAAO,iBAAiB,CAAC,WAAW,CAAC,KAAK,CAAC;gBA/DrC,CClDH,YAAY,mCACZ,YAAY,oBAuCO,MAAM,CAAC,QAAQ,SDYtB,CA8De;eACvB,kBAAkB,CAAC,IAAI,IAAI,KAAK,CAAC;IAC5C,CAAC;IAJe,8BAAW,cAI1B,CAAA;AACL,CAAC,EAlCgB,kBAAkB,GAAlB,0BAAkB,KAAlB,0BAAkB,QAkClC;AAuBD,IAAiB,UAAU,CA0C1B;AA1CD,WAAiB,UAAU;IACvB,gCAAgC;IAElB,eAAI,GAAG,kBAAkB,CAAC,IAAI,CAAC;IAC/B,cAAG,GAAG,kBAAkB,CAAC,GAAG,CAAC;IAE3C,mCAAmC;IAEnC,uBAAuB;IAET,cAAG,GAAG,SAAS,CAAC,GAAG,CAAC;IAClC,UAAU,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC;IAErC,0BAA0B;IAE1B,wBAAwB;IAExB;;OAEG;IACU,gBAAK,GAAG,MAAM,CAAC,GAAG,CAAC,wCAAwC,CAAC,CAAC;IAE1E,2BAA2B;IAEd,eAAI,GAAG,YAAY,CAAC;IAUjC;;OAEG;IACH,SAAgB,WAAW,CAAC,KAAU;QAClC,OAAO,kBAAkB,CAAC,WAAW,CAAC,KAAK,CAAC;eACrC,SAAS,CAAC,WAAW,CAAC,KAAK,CAAC;eAC5B,UAAU,CAAC,KAAK,IAAI,KAAK,CAAC;IACrC,CAAC;IAJe,sBAAW,cAI1B,CAAA;AACL,CAAC,EA1CgB,UAAU,GAAV,kBAAU,KAAV,kBAAU,QA0C1B;AA0BD,IAAiB,yBAAyB,CAwCzC;AAxCD,WAAiB,yBAAyB;IACtC,gCAAgC;IAElB,8BAAI,GAAG,kBAAkB,CAAC,IAAI,CAAC;IAC/B,6BAAG,GAAG,kBAAkB,CAAC,GAAG,CAAC;IAE3C,mCAAmC;IAEnC,uCAAuC;IAEvC;;OAEG;IACU,iCAAO,GAAG,MAAM,CAAC,GAAG,CAAC,yDAAyD,CAAC,CAAC;IAE7F;;OAEG;IACU,+BAAK,GAAG,MAAM,CAAC,GAAG,CAAC,uDAAuD,CAAC,CAAC;IAEzF,0CAA0C;IAE7B,8BAAI,GAAG,2BAA2B,CAAC;IAUhD;;OAEG;IACH,SAAgB,WAAW,CAAC,KAAc;QACtC,OAAO,kBAAkB,CAAC,WAAW,CAAC,KAAK,CAAC;eACrC,yBAAyB,CAAC,OAAO,IAAI,KAAK;eAC1C,yBAAyB,CAAC,KAAK,IAAI,KAAK,CAAC;IACpD,CAAC;IAJe,qCAAW,cAI1B,CAAA;AACL,CAAC,EAxCgB,yBAAyB,GAAzB,iCAAyB,KAAzB,iCAAyB,QAwCzC;AAUD,IAAiB,0BAA0B,CAyC1C;AAzCD,WAAiB,0BAA0B;IACvC,gCAAgC;IAElB,+BAAI,GAAG,kBAAkB,CAAC,IAAI,CAAC;IAC/B,8BAAG,GAAG,kBAAkB,CAAC,GAAG,CAAC;IAE3C,mCAAmC;IAEnC,uCAAuC;IAEzB,kCAAO,GAAG,yBAAyB,CAAC,OAAO,CAAC;IAC5C,gCAAK,GAAG,yBAAyB,CAAC,KAAK,CAAC;IAEtD,0CAA0C;IAE1C,wCAAwC;IAExC;;OAEG;IACU,gCAAK,GAAG,MAAM,CAAC,GAAG,CAAC,wDAAwD,CAAC,CAAC;IAE1F,2CAA2C;IAE9B,+BAAI,GAAG,4BAA4B,CAAC;IAUjD;;OAEG;IACH,SAAgB,WAAW,CAAC,KAAc;QACtC,OAAO,yBAAyB,CAAC,WAAW,CAAC,KAAK,CAAC;eAC5C,0BAA0B,CAAC,KAAK,IAAI,KAAK,CAAC;IACrD,CAAC;IAHe,sCAAW,cAG1B,CAAA;AACL,CAAC,EAzCgB,0BAA0B,GAA1B,kCAA0B,KAA1B,kCAA0B,QAyC1C;AAcD,IAAiB,iBAAiB,CA6DjC;AA7DD,WAAiB,iBAAiB;IAC9B,gCAAgC;IAElB,sBAAI,GAAG,kBAAkB,CAAC,IAAI,CAAC;IAC/B,qBAAG,GAAG,kBAAkB,CAAC,GAAG,CAAC;IAE3C,mCAAmC;IAEnC,uCAAuC;IAEzB,yBAAO,GAAG,yBAAyB,CAAC,OAAO,CAAC;IAC5C,uBAAK,GAAG,yBAAyB,CAAC,KAAK,CAAC;IAEtD,0CAA0C;IAE1C,wCAAwC;IAE1B,uBAAK,GAAG,0BAA0B,CAAC,KAAK,CAAC;IAEvD,2CAA2C;IAE3C,wBAAwB;IAEV,qBAAG,GAAG,UAAU,CAAC,GAAG,CAAC;IACnC,iBAAiB,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC;IAC/B,uBAAK,GAAG,UAAU,CAAC,KAAK,CAAC;IAEvC,2BAA2B;IAE3B,+BAA+B;IAE/B;;OAEG;IACU,0BAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,kDAAkD,CAAC,CAAC;IAEvF;;OAEG;IACU,0BAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,kDAAkD,CAAC,CAAC;IAEvF,kCAAkC;IAErB,sBAAI,GAAG,mBAAmB,CAAC;IAUxC;;OAEG;IACH,SAAgB,WAAW,CAAC,KAAc;QACtC,OAAO,0BAA0B,CAAC,WAAW,CAAC,KAAK,CAAC;eAC7C,iBAAiB,CAAC,QAAQ,IAAI,KAAK;eACnC,iBAAiB,CAAC,QAAQ,IAAI,KAAK,CAAC;IAC/C,CAAC;IAJe,6BAAW,cAI1B,CAAA;AACL,CAAC,EA7DgB,iBAAiB,GAAjB,yBAAiB,KAAjB,yBAAiB,QA6DjC;AAmBD,IAAiB,sBAAsB,CA6BtC;AA7BD,WAAiB,sBAAsB;IACnC,uCAAuC;IAEvC;;OAEG;IACU,0BAAG,GAAG,MAAM,CAAC,GAAG,CAAC,kDAAkD,CAAC,CAAC;IAElF;;OAEG;IACU,0BAAG,GAAG,MAAM,CAAC,GAAG,CAAC,kDAAkD,CAAC,CAAC;IAElF,0CAA0C;IAE7B,2BAAI,GAAG,wBAAwB,CAAC;IAM7C;;OAEG;IACH,SAAgB,WAAW,CAAC,KAAc;QACtC,OAAO,CClaJ,YAAY,KAAK,QDetB,IAAM,UCfsC,IDe1B,ICdb,YAAY,KAAK,UDkBzB,KAgZY,sBAAsB,CAAC,GAAG,IAAI,KAAK;eACnC,sBAAsB,CAAC,GAAG,IAAI,KAAK,CAAC;IAC/C,CAAC;IAJe,kCAAW,cAI1B,CAAA;AACL,CAAC,EA7BgB,sBAAsB,GAAtB,8BAAsB,KAAtB,8BAAsB,QA6BtC;AAeD,IAAiB,cAAc,CAiC9B;AAjCD,WAAiB,cAAc;IAC3B,uCAAuC;IAEzB,kBAAG,GAAG,sBAAsB,CAAC,GAAG,CAAC;IACjC,kBAAG,GAAG,sBAAsB,CAAC,GAAG,CAAC;IAE/C,0CAA0C;IAE1C,+BAA+B;IAE/B;;OAEG;IACU,kBAAG,GAAG,MAAM,CAAC,GAAG,CAAC,2CAA2C,CAAC,CAAC;IAE3E,cAAc,CAAC,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,8CAA8C,CAAkC,CAAC;IAEpH,kCAAkC;IAErB,mBAAI,GAAG,gBAAgB,CAAC;IAMrC;;OAEG;IACH,SAAgB,WAAW,CAAC,KAAc;QACtC,OAAO,sBAAsB,CAAC,WAAW,CAAC,KAAK,CAAC;eACzC,cAAc,CAAC,GAAG,IAAI,KAAK;eAC3B,cAAc,CAAC,MAAM,IAAI,KAAK,CAAC;IAC1C,CAAC;IAJe,0BAAW,cAI1B,CAAA;AACL,CAAC,EAjCgB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAiC9B;AA2BD,IAAiB,uBAAuB,CA+CvC;AA/CD,WAAiB,uBAAuB;IACpC,uCAAuC;IAEzB,2BAAG,GAAG,sBAAsB,CAAC,GAAG,CAAC;IACjC,2BAAG,GAAG,sBAAsB,CAAC,GAAG,CAAC;IAE/C,0CAA0C;IAE1C,wCAAwC;IAExC;;OAEG;IACU,4BAAI,GAAG,MAAM,CAAC,GAAG,CAAC,oDAAoD,CAAC,CAAC;IAErF;;OAEG;IACU,4BAAI,GAAG,MAAM,CAAC,GAAG,CAAC,oDAAoD,CAAC,CAAC;IAErF;;OAEG;IACU,8BAAM,GAAG,MAAM,CAAC,GAAG,CAAC,sDAAsD,CAAC,CAAC;IAEzF,2CAA2C;IAE9B,4BAAI,GAAG,yBAAyB,CAAC;IAU9C;;OAEG;IACH,SAAgB,WAAW,CAAC,KAAc;QACtC,OAAO,AAxeD,CClDH,YAAY,mCACZ,YAAY,oBAuCO,MAAM,CAAC,QAAQ,SDYtB,IAueR,sBAAsB,CAAC,WAAW,CAAC,KAAK,CAAC;eACzC,uBAAuB,CAAC,IAAI,IAAI,KAAK;eACrC,uBAAuB,CAAC,IAAI,IAAI,KAAK;eACrC,uBAAuB,CAAC,MAAM,IAAI,KAAK,CAAC;IACnD,CAAC;IANe,mCAAW,cAM1B,CAAA;AACL,CAAC,EA/CgB,uBAAuB,GAAvB,+BAAuB,KAAvB,+BAAuB,QA+CvC;AASD,IAAiB,eAAe,CA6C/B;AA7CD,WAAiB,eAAe;IAC5B,wCAAwC;IAE1B,oBAAI,GAAG,uBAAuB,CAAC,IAAI,CAAC;IACpC,mBAAG,GAAG,uBAAuB,CAAC,GAAG,CAAC;IAClC,mBAAG,GAAG,uBAAuB,CAAC,GAAG,CAAC;IAClC,oBAAI,GAAG,uBAAuB,CAAC,IAAI,CAAC;IACpC,sBAAM,GAAG,uBAAuB,CAAC,MAAM,CAAC;IAEtD,2CAA2C;IAE3C,+BAA+B;IAEjB,mBAAG,GAAG,cAAc,CAAC,GAAG,CAAC;IACvC,eAAe,CAAC,MAAM,GAAG,cAAc,CAAC,MAAM,CAAC;IAE/C,kCAAkC;IAElC,gCAAgC;IAEhC;;OAEG;IACU,qBAAK,GAAG,MAAM,CAAC,GAAG,CAAC,6CAA6C,CAAC,CAAC;IAE/E,mCAAmC;IAEtB,oBAAI,GAAG,iBAAiB,CAAC;IAUtC;;OAEG;IACH,SAAgB,WAAW,CAAC,KAAc;QACtC,OAAO,uBAAuB,CAAC,WAAW,CAAC,KAAK,CAAC;eAC1C,cAAc,CAAC,WAAW,CAAC,KAAK,CAAC;eACjC,eAAe,CAAC,KAAK,IAAI,KAAK,CAAC;IAC1C,CAAC;IAJe,2BAAW,cAI1B,CAAA;AACL,CAAC,EA7CgB,eAAe,GAAf,uBAAe,KAAf,uBAAe,QA6C/B;AA+CD,IAAiB,4BAA4B,CAyD5C;AAzDD,WAAiB,4BAA4B;IACzC,6CAA6C;IAE7C;;OAEG;IACU,iCAAI,GAAG,MAAM,CAAC,GAAG,CAAC,yDAAyD,CAAC,CAAC;IAE1F;;OAEG;IACU,gCAAG,GAAG,MAAM,CAAC,GAAG,CAAC,wDAAwD,CAAC,CAAC;IAExF;;OAEG;IACU,qCAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,6DAA6D,CAAC,CAAC;IAElG;;OAEG;IACU,gCAAG,GAAG,MAAM,CAAC,GAAG,CAAC,wDAAwD,CAAC,CAAC;IAExF;;OAEG;IACU,iCAAI,GAAG,MAAM,CAAC,GAAG,CAAC,yDAAyD,CAAC,CAAC;IAE1F;;OAEG;IACU,mCAAM,GAAG,MAAM,CAAC,GAAG,CAAC,2DAA2D,CAAC,CAAC;IAE9F,gDAAgD;IAEnC,iCAAI,GAAG,8BAA8B,CAAC;IAUnD;;OAEG;IACH,SAAgB,WAAW,CAAC,KAAc;QACtC,OAAO,AApoBD,CClDH,YAAY,mCACZ,YAAY,oBAuCO,MAAM,CAAC,QAAQ,SDYtB,IAmoBR,4BAA4B,CAAC,IAAI,IAAI,KAAK;eAC1C,4BAA4B,CAAC,GAAG,IAAI,KAAK;eACzC,4BAA4B,CAAC,QAAQ,IAAI,KAAK;eAC9C,4BAA4B,CAAC,GAAG,IAAI,KAAK;eACzC,4BAA4B,CAAC,IAAI,IAAI,KAAK;eAC1C,4BAA4B,CAAC,MAAM,IAAI,KAAK,CAAC;IACxD,CAAC;IARe,wCAAW,cAQ1B,CAAA;AACL,CAAC,EAzDgB,4BAA4B,GAA5B,oCAA4B,KAA5B,oCAA4B,QAyD5C;AA0BD,IAAiB,oBAAoB,CAqDpC;AArDD,WAAiB,oBAAoB;IACjC,6CAA6C;IAE/B,yBAAI,GAAG,4BAA4B,CAAC,IAAI,CAAC;IACzC,wBAAG,GAAG,4BAA4B,CAAC,GAAG,CAAC;IACvC,6BAAQ,GAAG,4BAA4B,CAAC,QAAQ,CAAC;IACjD,wBAAG,GAAG,4BAA4B,CAAC,GAAG,CAAC;IACvC,yBAAI,GAAG,4BAA4B,CAAC,IAAI,CAAC;IACzC,2BAAM,GAAG,4BAA4B,CAAC,MAAM,CAAC;IAE3D,gDAAgD;IAEhD,qCAAqC;IAErC;;OAEG;IACU,wBAAG,GAAG,MAAM,CAAC,GAAG,CAAC,gDAAgD,CAAC,CAAC;IAEhF,oBAAoB,CAAC,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,mDAAmD,CAAuC,CAAC;IAEpI;;OAEG;IACU,gCAAW,GAAG,MAAM,CAAC,GAAG,CAAC,wDAAwD,CAAC,CAAC;IAEhG;;OAEG;IACU,0BAAK,GAAG,MAAM,CAAC,GAAG,CAAC,kDAAkD,CAAC,CAAC;IAEpF,wCAAwC;IAE3B,yBAAI,GAAG,sBAAsB,CAAC;IAU3C;;OAEG;IACH,SAAgB,WAAW,CAAC,KAAc;QACtC,OAAO,4BAA4B,CAAC,WAAW,CAAC,KAAK,CAAC;eAC/C,oBAAoB,CAAC,GAAG,IAAI,KAAK;eACjC,oBAAoB,CAAC,MAAM,IAAI,KAAK;eACpC,oBAAoB,CAAC,WAAW,IAAI,KAAK;eACzC,oBAAoB,CAAC,KAAK,IAAI,KAAK,CAAC;IAC/C,CAAC;IANe,gCAAW,cAM1B,CAAA;AACL,CAAC,EArDgB,oBAAoB,GAApB,4BAAoB,KAApB,4BAAoB,QAqDpC","sourcesContent":["/*!\r\n   Copyright 2019 Ron Buckton\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n*/\r\n\r\nimport /*#__INLINE__*/ { isIterableObject, isObject } from \"@esfx/internal-guards\";\r\n\r\n/**\r\n * A {@link ReadonlyContainer} describes an object that can contain other values.\r\n */\r\nexport interface ReadonlyContainer<T> {\r\n    /**\r\n     * Tests whether an element is present in the container.\r\n     */\r\n    [ReadonlyContainer.has](value: T): boolean;\r\n}\r\n\r\nexport namespace ReadonlyContainer {\r\n    // #region ReadonlyContainer<T>\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyContainer#[ReadonlyContainer.has]` method.\r\n     */\r\n    export const has = Symbol.for(\"@esfx/collection-core!ReadonlyCollection.has\");\r\n\r\n    // #endregion ReadonlyContainer<T>\r\n\r\n    export const name = \"ReadonlyContainer\";\r\n\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a {@link ReadonlyContainer}.\r\n     */\r\n    export function hasInstance(value: any): value is ReadonlyContainer<unknown> {\r\n        return isObject(value)\r\n            && ReadonlyContainer.has in value;\r\n    }\r\n}\r\n\r\n/**\r\n * A {@link Container} describes a container object that can contain other values and\r\n * may have its contents modified.\r\n */\r\nexport interface Container<T> extends ReadonlyContainer<T> {\r\n    /**\r\n     * Adds an element to the container.\r\n     */\r\n    [Container.add](value: T): void;\r\n\r\n    /**\r\n     * Deletes an element from the container.\r\n     */\r\n    [Container.delete](value: T): boolean;\r\n}\r\n\r\nexport namespace Container {\r\n    // #region ReadonlyContainer<T>\r\n\r\n    export import has = ReadonlyContainer.has;\r\n\r\n    // #endregion ReadonlyContainer<T>\r\n\r\n    // #region Container<T>\r\n\r\n    /**\r\n     * A well-known symbol used to define the `Container#[Container.add]` method.\r\n     */\r\n    export const add = Symbol.for(\"@esfx/collection-core!Collection.add\");\r\n    Container.delete = Symbol.for(\"@esfx/collection-core!Collection.delete\") as typeof Container.delete;\r\n\r\n    // #endregion Collection<T>\r\n\r\n    export const name = \"Container\";\r\n\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a {@link Container}.\r\n     */\r\n    export function hasInstance(value: any): value is Container<unknown> {\r\n        return ReadonlyContainer.hasInstance(value)\r\n            && Container.add in value\r\n            && Container.delete in value;\r\n    }\r\n}\r\n\r\nexport declare namespace Container {\r\n    /**\r\n     * A well-known symbol used to define the `Container#[Container.delete]` method.\r\n     */\r\n    const _delete: unique symbol;\r\n    export { _delete as delete };\r\n}\r\n\r\n/**\r\n * A {@link ReadonlyCollection} describes a collection object, such as an Array or Set, that\r\n * can contain other values and has a known size.\r\n */\r\nexport interface ReadonlyCollection<T> extends Iterable<T>, ReadonlyContainer<T> {\r\n    /**\r\n     * Gets the number of elements in the collection.\r\n     */\r\n    readonly [ReadonlyCollection.size]: number;\r\n}\r\n\r\nexport namespace ReadonlyCollection {\r\n    // #region ReadonlyContainer<T>\r\n\r\n    export import has = ReadonlyContainer.has;\r\n\r\n    // #endregion ReadonlyContainer<T>\r\n\r\n    // #region ReadonlyCollection<T>\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyCollection#[ReadonlyCollection.size]` property.\r\n     */\r\n    export const size = Symbol.for(\"@esfx/collection-core!ReadonlyCollection.size\");\r\n\r\n    // #endregion ReadonlyCollection<T>\r\n\r\n    export const name = \"ReadonlyCollection\";\r\n\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyCollection`.\r\n     */\r\n    export function hasInstance<T>(value: Iterable<T>): value is ReadonlyCollection<T>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyCollection`.\r\n     */\r\n    export function hasInstance(value: any): value is ReadonlyCollection<unknown>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyCollection`.\r\n     */\r\n    export function hasInstance(value: any): value is ReadonlyCollection<unknown> {\r\n        return ReadonlyContainer.hasInstance(value)\r\n            && isIterableObject(value)\r\n            && ReadonlyCollection.size in value;\r\n    }\r\n}\r\n\r\n/**\r\n * A {@link Collection} describes a collection object, such as an Array or Set, that can\r\n * contain other values, has a known size, and may have its contents modified.\r\n */\r\nexport interface Collection<T> extends ReadonlyCollection<T>, Container<T> {\r\n    /**\r\n     * Adds an element to the collection.\r\n     */\r\n    [Collection.add](value: T): void;\r\n\r\n    /**\r\n     * Deletes an element from the collection.\r\n     */\r\n    [Collection.delete](value: T): boolean;\r\n\r\n    /**\r\n     * Clears the collection.\r\n     */\r\n    [Collection.clear](): void;\r\n}\r\n\r\nexport namespace Collection {\r\n    // #region ReadonlyCollection<T>\r\n\r\n    export import size = ReadonlyCollection.size;\r\n    export import has = ReadonlyCollection.has;\r\n\r\n    // #endregion ReadonlyCollection<T>\r\n\r\n    // #region Container<T>\r\n\r\n    export import add = Container.add;\r\n    Collection.delete = Container.delete;\r\n\r\n    // #endregion Container<T>\r\n\r\n    // #region Collection<T>\r\n\r\n    /**\r\n     * A well-known symbol used to define the `Collection#[Collection.clear]` method.\r\n     */\r\n    export const clear = Symbol.for(\"@esfx/collection-core!Collection.clear\");\r\n\r\n    // #endregion Collection<T>\r\n\r\n    export const name = \"Collection\";\r\n\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `Collection`.\r\n     */\r\n    export function hasInstance<T>(value: Iterable<T>): value is Collection<T>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `Collection`.\r\n     */\r\n    export function hasInstance(value: any): value is Collection<unknown>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `Collection`.\r\n     */\r\n    export function hasInstance(value: any): value is Collection<unknown> {\r\n        return ReadonlyCollection.hasInstance(value)\r\n            && Container.hasInstance(value)\r\n            && Collection.clear in value;\r\n    }\r\n}\r\n\r\nexport declare namespace Collection {\r\n    /**\r\n     * A well-known symbol used to define the `Collection#[Collection.delete]` method.\r\n     */\r\n    const _delete: typeof Container.delete;\r\n    export { _delete as delete };\r\n}\r\n\r\n/**\r\n * A {@link ReadonlyIndexedCollection} describes an indexed collection object, such as an Array, that\r\n * can contain other values, has a known size, and whose elements can be accessed by ordinal index.\r\n */\r\nexport interface ReadonlyIndexedCollection<T> extends ReadonlyCollection<T> {\r\n    /**\r\n     * Gets the index for a value in the collection, or `-1` if the value was not found.\r\n     */\r\n    [ReadonlyIndexedCollection.indexOf](value: T, fromIndex?: number): number;\r\n\r\n    /**\r\n     * Gets the value at the specified index in the collection, or `undefined` if the index was outside of the bounds of the collection.\r\n     */\r\n    [ReadonlyIndexedCollection.getAt](index: number): T | undefined;\r\n}\r\n\r\nexport namespace ReadonlyIndexedCollection {\r\n    // #region ReadonlyCollection<T>\r\n\r\n    export import size = ReadonlyCollection.size;\r\n    export import has = ReadonlyCollection.has;\r\n\r\n    // #endregion ReadonlyCollection<T>\r\n\r\n    // #region ReadonlyIndexedCollection<T>\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyIndexedCollection#[ReadonlyIndexedCollection.indexOf]` method.\r\n     */\r\n    export const indexOf = Symbol.for(\"@esfx/collection-core!ReadonlyIndexedCollection.indexOf\");\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyIndexedCollection#[ReadonlyIndexedCollection.getAt]` method.\r\n     */\r\n    export const getAt = Symbol.for(\"@esfx/collection-core!ReadonlyIndexedCollection.getAt\");\r\n\r\n    // #endregion ReadonlyIndexedCollection<T>\r\n\r\n    export const name = \"ReadonlyIndexedCollection\";\r\n\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyIndexedCollection`.\r\n     */\r\n    export function hasInstance<T>(value: Iterable<T>): value is ReadonlyIndexedCollection<T>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyIndexedCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is ReadonlyIndexedCollection<unknown>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyIndexedCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is ReadonlyIndexedCollection<unknown> {\r\n        return ReadonlyCollection.hasInstance(value)\r\n            && ReadonlyIndexedCollection.indexOf in value\r\n            && ReadonlyIndexedCollection.getAt in value;\r\n    }\r\n}\r\n\r\nexport interface FixedSizeIndexedCollection<T> extends ReadonlyIndexedCollection<T> {\r\n    /**\r\n     * Sets a value at the specified index in the collection.\r\n     * @returns `true` if the value was set at the provided index, otherwise `false`.\r\n     */\r\n    [FixedSizeIndexedCollection.setAt](index: number, value: T): boolean;\r\n}\r\n\r\nexport namespace FixedSizeIndexedCollection {\r\n    // #region ReadonlyCollection<T>\r\n\r\n    export import size = ReadonlyCollection.size;\r\n    export import has = ReadonlyCollection.has;\r\n\r\n    // #endregion ReadonlyCollection<T>\r\n\r\n    // #region ReadonlyIndexedCollection<T>\r\n\r\n    export import indexOf = ReadonlyIndexedCollection.indexOf;\r\n    export import getAt = ReadonlyIndexedCollection.getAt;\r\n\r\n    // #endregion ReadonlyIndexedCollection<T>\r\n\r\n    // #region FixedSizeIndexedCollection<T>\r\n\r\n    /**\r\n     * A well-known symbol used to define the `FixedSizeIndexedCollection#[FixedSizeIndexedCollection.setAt]` method.\r\n     */\r\n    export const setAt = Symbol.for(\"@esfx/collection-core!FixedSizeIndexedCollection.setAt\");\r\n\r\n    // #endregion FixedSizeIndexedCollection<T>\r\n\r\n    export const name = \"FixedSizeIndexedCollection\";\r\n\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `FixedSizeIndexedCollection`.\r\n     */\r\n    export function hasInstance<T>(value: Iterable<T>): value is FixedSizeIndexedCollection<T>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `FixedSizeIndexedCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is FixedSizeIndexedCollection<unknown>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `FixedSizeIndexedCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is FixedSizeIndexedCollection<unknown> {\r\n        return ReadonlyIndexedCollection.hasInstance(value)\r\n            && FixedSizeIndexedCollection.setAt in value;\r\n    }\r\n}\r\n\r\nexport interface IndexedCollection<T> extends FixedSizeIndexedCollection<T>, Collection<T> {\r\n    /**\r\n     * Inserts a value at the specified index in the collection, shifting any following elements to the right one position.\r\n     */\r\n    [IndexedCollection.insertAt](index: number, value: T): void;\r\n\r\n    /**\r\n     * Removes the value at the specified index in the collection, shifting any following elements to the left one position.\r\n     */\r\n    [IndexedCollection.removeAt](index: number): void;\r\n}\r\n\r\nexport namespace IndexedCollection {\r\n    // #region ReadonlyCollection<T>\r\n\r\n    export import size = ReadonlyCollection.size;\r\n    export import has = ReadonlyCollection.has;\r\n\r\n    // #endregion ReadonlyCollection<T>\r\n\r\n    // #region ReadonlyIndexedCollection<T>\r\n\r\n    export import indexOf = ReadonlyIndexedCollection.indexOf;\r\n    export import getAt = ReadonlyIndexedCollection.getAt;\r\n\r\n    // #endregion ReadonlyIndexedCollection<T>\r\n\r\n    // #region FixedSizeIndexedCollection<T>\r\n\r\n    export import setAt = FixedSizeIndexedCollection.setAt;\r\n\r\n    // #endregion FixedSizeIndexedCollection<T>\r\n\r\n    // #region Collection<T>\r\n\r\n    export import add = Collection.add;\r\n    IndexedCollection.delete = Collection.delete;\r\n    export import clear = Collection.clear;\r\n\r\n    // #endregion Collection<T>\r\n\r\n    // #region IndexedCollection<T>\r\n\r\n    /**\r\n     * A well-known symbol used to define the `IndexedCollection#[IndexedCollection.insertAt]` method.\r\n     */\r\n    export const insertAt = Symbol.for(\"@esfx/collection-core!IndexedCollection.insertAt\");\r\n\r\n    /**\r\n     * A well-known symbol used to define the `IndexedCollection#[IndexedCollection.removeAt]` method.\r\n     */\r\n    export const removeAt = Symbol.for(\"@esfx/collection-core!IndexedCollection.removeAt\");\r\n\r\n    // #endregion IndexedCollection<T>\r\n\r\n    export const name = \"IndexedCollection\";\r\n\r\n    /**\r\n     * Tests whether a value supports the minimal representation of an `IndexedCollection`.\r\n     */\r\n    export function hasInstance<T>(value: Iterable<T>): value is IndexedCollection<T>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of an `IndexedCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is IndexedCollection<unknown>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of an `IndexedCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is IndexedCollection<unknown> {\r\n        return FixedSizeIndexedCollection.hasInstance(value)\r\n            && IndexedCollection.insertAt in value\r\n            && IndexedCollection.removeAt in value;\r\n    }\r\n}\r\n\r\nexport declare namespace IndexedCollection {\r\n    const _delete: typeof Collection.delete;\r\n    export { _delete as delete };\r\n}\r\n\r\nexport interface ReadonlyKeyedContainer<K, V> {\r\n    /**\r\n     * Tests whether a key is present in the container.\r\n     */\r\n    [ReadonlyKeyedContainer.has](key: K): boolean;\r\n\r\n    /**\r\n     * Gets the value in the container associated with the provided key, if it exists.\r\n     */\r\n    [ReadonlyKeyedContainer.get](key: K): V | undefined;\r\n}\r\n\r\nexport namespace ReadonlyKeyedContainer {\r\n    // #region ReadonlyKeyedContainer<K, V>\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyKeyedContainer#[ReadonlyKeyedContainer.has]` method.\r\n     */\r\n    export const has = Symbol.for(\"@esfx/collection-core!ReadonlyKeyedContainer.has\");\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyKeyedContainer#[ReadonlyKeyedContainer.get]` method.\r\n     */\r\n    export const get = Symbol.for(\"@esfx/collection-core!ReadonlyKeyedContainer.get\");\r\n\r\n    // #endregion ReadonlyKeyedContainer<K, V>\r\n\r\n    export const name = \"ReadonlyKeyedContainer\";\r\n\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyKeyedContainer`.\r\n     */\r\n    export function hasInstance(value: unknown): value is ReadonlyKeyedContainer<unknown, unknown>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyKeyedCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is ReadonlyKeyedContainer<unknown, unknown> {\r\n        return isObject(value)\r\n            && ReadonlyKeyedContainer.has in value\r\n            && ReadonlyKeyedContainer.get in value;\r\n    }\r\n}\r\n\r\nexport interface KeyedContainer<K, V> extends ReadonlyKeyedContainer<K, V> {\r\n    /**\r\n     * Sets a value in the container for the provided key.\r\n     */\r\n    [KeyedContainer.set](key: K, value: V): void;\r\n\r\n    /**\r\n     * Deletes a key and its associated value from the container.\r\n     * @returns `true` if the key was found and removed; otherwise, `false`.\r\n     */\r\n    [KeyedContainer.delete](key: K): boolean;\r\n}\r\n\r\nexport namespace KeyedContainer {\r\n    // #region ReadonlyKeyedContainer<K, V>\r\n\r\n    export import has = ReadonlyKeyedContainer.has;\r\n    export import get = ReadonlyKeyedContainer.get;\r\n\r\n    // #endregion ReadonlyKeyedContainer<K, V>\r\n\r\n    // #region KeyedContainer<K, V>\r\n\r\n    /**\r\n     * A well-known symbol used to define the `KeyedContainer#[KeyedContainer.set]` method.\r\n     */\r\n    export const set = Symbol.for(\"@esfx/collection-core!KeyedCollection.set\");\r\n\r\n    KeyedContainer.delete = Symbol.for(\"@esfx/collection-core!KeyedCollection.delete\") as typeof KeyedCollection.delete;\r\n\r\n    // #endregion KeyedContainer<K, V>\r\n\r\n    export const name = \"KeyedContainer\";\r\n\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `KeyedContainer`.\r\n     */\r\n    export function hasInstance(value: unknown): value is KeyedContainer<unknown, unknown>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `KeyedContainer`.\r\n     */\r\n    export function hasInstance(value: unknown): value is KeyedContainer<unknown, unknown> {\r\n        return ReadonlyKeyedContainer.hasInstance(value)\r\n            && KeyedContainer.set in value\r\n            && KeyedContainer.delete in value;\r\n    }\r\n}\r\n\r\nexport declare namespace KeyedContainer {\r\n    /**\r\n     * A well-known symbol used to define the `KeyedContainer#[KeyedContainer.delete]` method.\r\n     */\r\n    const _delete: unique symbol;\r\n    export { _delete as delete };\r\n}\r\n\r\nexport interface ReadonlyKeyedCollection<K, V> extends ReadonlyKeyedContainer<K, V>, Iterable<[K, V]> {\r\n    /**\r\n     * Gets the number of elements in the collection.\r\n     */\r\n    readonly [ReadonlyKeyedCollection.size]: number;\r\n\r\n    /**\r\n     * Gets an `IterableIterator` for the keys present in the collection.\r\n     */\r\n    [ReadonlyKeyedCollection.keys](): IterableIterator<K>;\r\n\r\n    /**\r\n     * Gets an `IterableIterator` for the values present in the collection.\r\n     */\r\n    [ReadonlyKeyedCollection.values](): IterableIterator<V>;\r\n}\r\n\r\nexport namespace ReadonlyKeyedCollection {\r\n    // #region ReadonlyKeyedContainer<K, V>\r\n\r\n    export import has = ReadonlyKeyedContainer.has;\r\n    export import get = ReadonlyKeyedContainer.get;\r\n\r\n    // #endregion ReadonlyKeyedContainer<K, V>\r\n\r\n    // #region ReadonlyKeyedCollection<K, V>\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyKeyedCollection#[ReadonlyKeyedCollection.size]` property.\r\n     */\r\n    export const size = Symbol.for(\"@esfx/collection-core!ReadonlyKeyedCollection.size\");\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyKeyedCollection#[ReadonlyKeyedCollection.keys]` method.\r\n     */\r\n    export const keys = Symbol.for(\"@esfx/collection-core!ReadonlyKeyedCollection.keys\");\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyKeyedCollection#[ReadonlyKeyedCollection.values]` method.\r\n     */\r\n    export const values = Symbol.for(\"@esfx/collection-core!ReadonlyKeyedCollection.values\");\r\n\r\n    // #endregion ReadonlyKeyedCollection<K, V>\r\n\r\n    export const name = \"ReadonlyKeyedCollection\";\r\n\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyKeyedCollection`.\r\n     */\r\n    export function hasInstance<K, V>(value: Iterable<[K, V]>): value is ReadonlyKeyedCollection<K, V>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyKeyedCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is ReadonlyKeyedCollection<unknown, unknown>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyKeyedCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is ReadonlyKeyedCollection<unknown, unknown> {\r\n        return isIterableObject(value)\r\n            && ReadonlyKeyedContainer.hasInstance(value)\r\n            && ReadonlyKeyedCollection.size in value\r\n            && ReadonlyKeyedCollection.keys in value\r\n            && ReadonlyKeyedCollection.values in value;\r\n    }\r\n}\r\n\r\nexport interface KeyedCollection<K, V> extends ReadonlyKeyedCollection<K, V>, KeyedContainer<K, V> {\r\n    /**\r\n     * Clears the collection.\r\n     */\r\n    [KeyedCollection.clear](): void;\r\n}\r\n\r\nexport namespace KeyedCollection {\r\n    // #region ReadonlyKeyedCollection<K, V>\r\n\r\n    export import size = ReadonlyKeyedCollection.size;\r\n    export import has = ReadonlyKeyedCollection.has;\r\n    export import get = ReadonlyKeyedCollection.get;\r\n    export import keys = ReadonlyKeyedCollection.keys;\r\n    export import values = ReadonlyKeyedCollection.values;\r\n\r\n    // #endregion ReadonlyKeyedCollection<K, V>\r\n\r\n    // #region KeyedContainer<K, V>\r\n\r\n    export import set = KeyedContainer.set;\r\n    KeyedCollection.delete = KeyedContainer.delete;\r\n\r\n    // #endregion KeyedContainer<K, V>\r\n\r\n    // #region KeyedCollection<K, V>\r\n\r\n    /**\r\n     * A well-known symbol used to define the `KeyedCollection#[KeyedCollection.clear]` method.\r\n     */\r\n    export const clear = Symbol.for(\"@esfx/collection-core!KeyedCollection.clear\");\r\n\r\n    // #endregion KeyedCollection<K, V>\r\n\r\n    export const name = \"KeyedCollection\";\r\n\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `KeyedCollection`.\r\n     */\r\n    export function hasInstance<K, V>(value: Iterable<[K, V]>): value is KeyedCollection<K, V>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `KeyedCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is KeyedCollection<unknown, unknown>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `KeyedCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is KeyedCollection<unknown, unknown> {\r\n        return ReadonlyKeyedCollection.hasInstance(value)\r\n            && KeyedContainer.hasInstance(value)\r\n            && KeyedCollection.clear in value;\r\n    }\r\n}\r\n\r\nexport declare namespace KeyedCollection {\r\n    /**\r\n     * A well-known symbol used to define the `KeyedCollection#[KeyedCollection.delete]` method.\r\n     */\r\n    const _delete: typeof KeyedContainer.delete;\r\n    export { _delete as delete };\r\n}\r\n\r\n/**\r\n * A {@link ReadonlyKeyedMultiCollection} describes a keyed collection object that can contain other\r\n * values, has a known size, and whose elements can be accessed by key, where each key can represent\r\n * one or more elements.\r\n */\r\nexport interface ReadonlyKeyedMultiCollection<K, V> extends Iterable<[K, V]> {\r\n    /**\r\n     * Gets the number of elements in the collection.\r\n     */\r\n    readonly [ReadonlyKeyedMultiCollection.size]: number;\r\n\r\n    /**\r\n     * Tests whether a key is present in the collection.\r\n     */\r\n    [ReadonlyKeyedMultiCollection.has](key: K): boolean;\r\n\r\n    /**\r\n     * Tests whether a key and value is present in the collection.\r\n     */\r\n    [ReadonlyKeyedMultiCollection.hasValue](key: K, value: V): boolean;\r\n\r\n    /**\r\n     * Gets the value in the collection associated with the provided key, if it exists.\r\n     */\r\n    [ReadonlyKeyedMultiCollection.get](key: K): Iterable<V> | undefined;\r\n\r\n    /**\r\n     * Gets an `IterableIterator` for the keys present in the collection.\r\n     */\r\n    [ReadonlyKeyedMultiCollection.keys](): IterableIterator<K>;\r\n\r\n    /**\r\n     * Gets an `IterableIterator` for the values present in the collection.\r\n     */\r\n    [ReadonlyKeyedMultiCollection.values](): IterableIterator<V>;\r\n}\r\n\r\nexport namespace ReadonlyKeyedMultiCollection {\r\n    // #region ReadonlyKeyedMultiCollection<K, V>\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.size]` property.\r\n     */\r\n    export const size = Symbol.for(\"@esfx/collection-core!ReadonlyKeyedMultiCollection.size\");\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.has]` method.\r\n     */\r\n    export const has = Symbol.for(\"@esfx/collection-core!ReadonlyKeyedMultiCollection.has\");\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.hasValue]` method.\r\n     */\r\n    export const hasValue = Symbol.for(\"@esfx/collection-core!ReadonlyKeyedMultiCollection.hasValue\");\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.get]` method.\r\n     */\r\n    export const get = Symbol.for(\"@esfx/collection-core!ReadonlyKeyedMultiCollection.get\");\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.keys]` method.\r\n     */\r\n    export const keys = Symbol.for(\"@esfx/collection-core!ReadonlyKeyedMultiCollection.keys\");\r\n\r\n    /**\r\n     * A well-known symbol used to define the `ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.values]` method.\r\n     */\r\n    export const values = Symbol.for(\"@esfx/collection-core!ReadonlyKeyedMultiCollection.values\");\r\n\r\n    // #endregion ReadonlyKeyedMultiCollection<K, V>\r\n\r\n    export const name = \"ReadonlyKeyedMultiCollection\";\r\n\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyKeyedMultiCollection`.\r\n     */\r\n    export function hasInstance<K, V>(value: Iterable<[K, V]>): value is ReadonlyKeyedMultiCollection<K, V>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyKeyedMultiCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is ReadonlyKeyedMultiCollection<unknown, unknown>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `ReadonlyKeyedMultiCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is ReadonlyKeyedMultiCollection<unknown, unknown> {\r\n        return isIterableObject(value)\r\n            && ReadonlyKeyedMultiCollection.size in value\r\n            && ReadonlyKeyedMultiCollection.has in value\r\n            && ReadonlyKeyedMultiCollection.hasValue in value\r\n            && ReadonlyKeyedMultiCollection.get in value\r\n            && ReadonlyKeyedMultiCollection.keys in value\r\n            && ReadonlyKeyedMultiCollection.values in value;\r\n    }\r\n}\r\n\r\nexport interface KeyedMultiCollection<K, V> extends ReadonlyKeyedMultiCollection<K, V> {\r\n    /**\r\n     * Adds a value to the collection for the provided key.\r\n     */\r\n    [KeyedMultiCollection.add](key: K, value: V): void;\r\n\r\n    /**\r\n     * Deletes a key and its associated values from the collection.\r\n     * @returns The number of values removed when the key was deleted.\r\n     */\r\n    [KeyedMultiCollection.delete](key: K): number;\r\n\r\n    /**\r\n     * Deletes a key and its associated value from the collection.\r\n     * @returns `true` if the key and value were found and removed; otherwise, `false`.\r\n     */\r\n    [KeyedMultiCollection.deleteValue](key: K, value: V): boolean;\r\n\r\n    /**\r\n     * Clears the collection.\r\n     */\r\n    [KeyedMultiCollection.clear](): void;\r\n}\r\n\r\nexport namespace KeyedMultiCollection {\r\n    // #region ReadonlyKeyedMultiCollection<K, V>\r\n\r\n    export import size = ReadonlyKeyedMultiCollection.size;\r\n    export import has = ReadonlyKeyedMultiCollection.has;\r\n    export import hasValue = ReadonlyKeyedMultiCollection.hasValue;\r\n    export import get = ReadonlyKeyedMultiCollection.get;\r\n    export import keys = ReadonlyKeyedMultiCollection.keys;\r\n    export import values = ReadonlyKeyedMultiCollection.values;\r\n\r\n    // #endregion ReadonlyKeyedMultiCollection<K, V>\r\n\r\n    // #region KeyedMultiCollection<K, V>\r\n\r\n    /**\r\n     * A well-known symbol used to define the `KeyedMultiCollection#[KeyedMultiCollection.add]` method.\r\n     */\r\n    export const add = Symbol.for(\"@esfx/collection-core!KeyedMultiCollection.add\");\r\n\r\n    KeyedMultiCollection.delete = Symbol.for(\"@esfx/collection-core!KeyedMultiCollection.delete\") as typeof KeyedMultiCollection.delete;\r\n\r\n    /**\r\n     * A well-known symbol used to define the `KeyedMultiCollection#[KeyedMultiCollection.deleteValue]` method.\r\n     */\r\n    export const deleteValue = Symbol.for(\"@esfx/collection-core!KeyedMultiCollection.deleteValue\");\r\n\r\n    /**\r\n     * A well-known symbol used to define the `KeyedMultiCollection#[KeyedMultiCollection.clear]` method.\r\n     */\r\n    export const clear = Symbol.for(\"@esfx/collection-core!KeyedMultiCollection.clear\");\r\n\r\n    // #endregion KeyedMultiCollection<K, V>\r\n\r\n    export const name = \"KeyedMultiCollection\";\r\n\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `KeyedMultiCollection`.\r\n     */\r\n    export function hasInstance<K, V>(value: Iterable<[K, V]>): value is KeyedMultiCollection<K, V>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `KeyedMultiCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is KeyedMultiCollection<unknown, unknown>;\r\n    /**\r\n     * Tests whether a value supports the minimal representation of a `KeyedMultiCollection`.\r\n     */\r\n    export function hasInstance(value: unknown): value is KeyedMultiCollection<unknown, unknown> {\r\n        return ReadonlyKeyedMultiCollection.hasInstance(value)\r\n            && KeyedMultiCollection.add in value\r\n            && KeyedMultiCollection.delete in value\r\n            && KeyedMultiCollection.deleteValue in value\r\n            && KeyedMultiCollection.clear in value;\r\n    }\r\n}\r\n\r\nexport declare namespace KeyedMultiCollection {\r\n    /**\r\n     * A well-known symbol used to define the `KeyedMultiCollection#[KeyedMultiCollection.delete]` method.\r\n     */\r\n    const _delete: unique symbol;\r\n    export { _delete as delete };\r\n}\r\n","\"use strict\";\n/*\n   Copyright 2019 Ron Buckton\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isPrimitive = exports.isPropertyKey = exports.isString = exports.isBoolean = exports.isPositiveInteger = exports.isInteger = exports.isPositiveNonZeroFiniteNumber = exports.isPositiveFiniteNumber = exports.isNumber = exports.isIterator = exports.isAsyncIterableObject = exports.isAsyncIterable = exports.isIterableObject = exports.isIterable = exports.isPresent = exports.isMissing = exports.isDefined = exports.isUndefined = exports.isInstance = exports.isObject = exports.isFunctionOrUndefined = exports.isFunction = void 0;\n/*@internal*/\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\nexports.isFunction = isFunction;\n/*@internal*/\nfunction isFunctionOrUndefined(value) {\n    return typeof value === \"function\" || value === undefined;\n}\nexports.isFunctionOrUndefined = isFunctionOrUndefined;\n/*@internal*/\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null\n        || typeof value === \"function\";\n}\nexports.isObject = isObject;\n/*@internal*/\nfunction isInstance(value, ctor) {\n    return !isMissing(value) && value instanceof ctor;\n}\nexports.isInstance = isInstance;\n/*@internal*/\nfunction isUndefined(value) {\n    return value === undefined;\n}\nexports.isUndefined = isUndefined;\n/*@internal*/\nfunction isDefined(value) {\n    return value === undefined;\n}\nexports.isDefined = isDefined;\n/*@internal*/\nfunction isMissing(value) {\n    return value === null\n        || value === undefined;\n}\nexports.isMissing = isMissing;\n/*@internal*/\nfunction isPresent(value) {\n    return value !== null\n        && value !== undefined;\n}\nexports.isPresent = isPresent;\n/*@internal*/\nfunction isIterable(value) {\n    return value !== undefined\n        && value !== null\n        && Symbol.iterator in Object(value);\n}\nexports.isIterable = isIterable;\n/*@internal*/\nfunction isIterableObject(value) {\n    return isObject(value) && Symbol.iterator in value;\n}\nexports.isIterableObject = isIterableObject;\n/*@internal*/\nfunction isAsyncIterable(value) {\n    return value !== undefined\n        && value !== null\n        && Symbol.asyncIterator in Object(value);\n}\nexports.isAsyncIterable = isAsyncIterable;\n/*@internal*/\nfunction isAsyncIterableObject(value) {\n    return isObject(value) && Symbol.asyncIterator in value;\n}\nexports.isAsyncIterableObject = isAsyncIterableObject;\n/** @internal */\nfunction isIterator(value) {\n    return isObject(value)\n        && isFunction(value.next)\n        && isFunctionOrUndefined(value.throw)\n        && isFunctionOrUndefined(value.return)\n        && isFunctionOrUndefined(value[Symbol.iterator]);\n}\nexports.isIterator = isIterator;\n;\n;\n;\n;\n/*@internal*/\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\nexports.isNumber = isNumber;\n/*@internal*/\nfunction isPositiveFiniteNumber(value) {\n    return isFinite(value) && value >= 0;\n}\nexports.isPositiveFiniteNumber = isPositiveFiniteNumber;\n/*@internal*/\nfunction isPositiveNonZeroFiniteNumber(value) {\n    return isFinite(value) && value > 0;\n}\nexports.isPositiveNonZeroFiniteNumber = isPositiveNonZeroFiniteNumber;\n/*@internal*/\nfunction isInteger(value) {\n    return Object.is(value, value | 0);\n}\nexports.isInteger = isInteger;\n/*@internal*/\nfunction isPositiveInteger(value) {\n    return isInteger(value) && value >= 0;\n}\nexports.isPositiveInteger = isPositiveInteger;\n/*@internal*/\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\nexports.isBoolean = isBoolean;\n/*@internal*/\nfunction isString(value) {\n    return typeof value === \"string\";\n}\nexports.isString = isString;\n/*@internal*/\nfunction isPropertyKey(value) {\n    return typeof value === \"string\"\n        || typeof value === \"symbol\"\n        || typeof value === \"number\";\n}\nexports.isPropertyKey = isPropertyKey;\n/*@internal*/\nfunction isPrimitive(value) {\n    return typeof value !== \"function\"\n        && (typeof value !== \"object\" || value === null);\n}\nexports.isPrimitive = isPrimitive;\n//# sourceMappingURL=index.js.map"]}