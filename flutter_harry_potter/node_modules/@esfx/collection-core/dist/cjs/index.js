"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyedMultiCollection = exports.ReadonlyKeyedMultiCollection = exports.KeyedCollection = exports.ReadonlyKeyedCollection = exports.KeyedContainer = exports.ReadonlyKeyedContainer = exports.IndexedCollection = exports.FixedSizeIndexedCollection = exports.ReadonlyIndexedCollection = exports.Collection = exports.ReadonlyCollection = exports.Container = exports.ReadonlyContainer = void 0;
var ReadonlyContainer;
(function (ReadonlyContainer) {
    // #region ReadonlyContainer<T>
    /**
     * A well-known symbol used to define the `ReadonlyContainer#[ReadonlyContainer.has]` method.
     */
    ReadonlyContainer.has = Symbol.for("@esfx/collection-core!ReadonlyCollection.has");
    // #endregion ReadonlyContainer<T>
    ReadonlyContainer.name = "ReadonlyContainer";
    /**
     * Tests whether a value supports the minimal representation of a {@link ReadonlyContainer}.
     */
    function hasInstance(value) {
        return (typeof value === "object" && value !== null || typeof value === "function") && ReadonlyContainer.has in value;
    }
    ReadonlyContainer.hasInstance = hasInstance;
})(ReadonlyContainer = exports.ReadonlyContainer || (exports.ReadonlyContainer = {}));
var Container;
(function (Container) {
    // #region ReadonlyContainer<T>
    Container.has = ReadonlyContainer.has;
    // #endregion ReadonlyContainer<T>
    // #region Container<T>
    /**
     * A well-known symbol used to define the `Container#[Container.add]` method.
     */
    Container.add = Symbol.for("@esfx/collection-core!Collection.add");
    Container.delete = Symbol.for("@esfx/collection-core!Collection.delete");
    // #endregion Collection<T>
    Container.name = "Container";
    /**
     * Tests whether a value supports the minimal representation of a {@link Container}.
     */
    function hasInstance(value) {
        return ReadonlyContainer.hasInstance(value)
            && Container.add in value
            && Container.delete in value;
    }
    Container.hasInstance = hasInstance;
})(Container = exports.Container || (exports.Container = {}));
var ReadonlyCollection;
(function (ReadonlyCollection) {
    // #region ReadonlyContainer<T>
    ReadonlyCollection.has = ReadonlyContainer.has;
    // #endregion ReadonlyContainer<T>
    // #region ReadonlyCollection<T>
    /**
     * A well-known symbol used to define the `ReadonlyCollection#[ReadonlyCollection.size]` property.
     */
    ReadonlyCollection.size = Symbol.for("@esfx/collection-core!ReadonlyCollection.size");
    // #endregion ReadonlyCollection<T>
    ReadonlyCollection.name = "ReadonlyCollection";
    /**
     * Tests whether a value supports the minimal representation of a `ReadonlyCollection`.
     */
    function hasInstance(value) {
        return ReadonlyContainer.hasInstance(value)
            && ((typeof value === "object" && value !== null || typeof value === "function") && Symbol.iterator in value)
            && ReadonlyCollection.size in value;
    }
    ReadonlyCollection.hasInstance = hasInstance;
})(ReadonlyCollection = exports.ReadonlyCollection || (exports.ReadonlyCollection = {}));
var Collection;
(function (Collection) {
    // #region ReadonlyCollection<T>
    Collection.size = ReadonlyCollection.size;
    Collection.has = ReadonlyCollection.has;
    // #endregion ReadonlyCollection<T>
    // #region Container<T>
    Collection.add = Container.add;
    Collection.delete = Container.delete;
    // #endregion Container<T>
    // #region Collection<T>
    /**
     * A well-known symbol used to define the `Collection#[Collection.clear]` method.
     */
    Collection.clear = Symbol.for("@esfx/collection-core!Collection.clear");
    // #endregion Collection<T>
    Collection.name = "Collection";
    /**
     * Tests whether a value supports the minimal representation of a `Collection`.
     */
    function hasInstance(value) {
        return ReadonlyCollection.hasInstance(value)
            && Container.hasInstance(value)
            && Collection.clear in value;
    }
    Collection.hasInstance = hasInstance;
})(Collection = exports.Collection || (exports.Collection = {}));
var ReadonlyIndexedCollection;
(function (ReadonlyIndexedCollection) {
    // #region ReadonlyCollection<T>
    ReadonlyIndexedCollection.size = ReadonlyCollection.size;
    ReadonlyIndexedCollection.has = ReadonlyCollection.has;
    // #endregion ReadonlyCollection<T>
    // #region ReadonlyIndexedCollection<T>
    /**
     * A well-known symbol used to define the `ReadonlyIndexedCollection#[ReadonlyIndexedCollection.indexOf]` method.
     */
    ReadonlyIndexedCollection.indexOf = Symbol.for("@esfx/collection-core!ReadonlyIndexedCollection.indexOf");
    /**
     * A well-known symbol used to define the `ReadonlyIndexedCollection#[ReadonlyIndexedCollection.getAt]` method.
     */
    ReadonlyIndexedCollection.getAt = Symbol.for("@esfx/collection-core!ReadonlyIndexedCollection.getAt");
    // #endregion ReadonlyIndexedCollection<T>
    ReadonlyIndexedCollection.name = "ReadonlyIndexedCollection";
    /**
     * Tests whether a value supports the minimal representation of a `ReadonlyIndexedCollection`.
     */
    function hasInstance(value) {
        return ReadonlyCollection.hasInstance(value)
            && ReadonlyIndexedCollection.indexOf in value
            && ReadonlyIndexedCollection.getAt in value;
    }
    ReadonlyIndexedCollection.hasInstance = hasInstance;
})(ReadonlyIndexedCollection = exports.ReadonlyIndexedCollection || (exports.ReadonlyIndexedCollection = {}));
var FixedSizeIndexedCollection;
(function (FixedSizeIndexedCollection) {
    // #region ReadonlyCollection<T>
    FixedSizeIndexedCollection.size = ReadonlyCollection.size;
    FixedSizeIndexedCollection.has = ReadonlyCollection.has;
    // #endregion ReadonlyCollection<T>
    // #region ReadonlyIndexedCollection<T>
    FixedSizeIndexedCollection.indexOf = ReadonlyIndexedCollection.indexOf;
    FixedSizeIndexedCollection.getAt = ReadonlyIndexedCollection.getAt;
    // #endregion ReadonlyIndexedCollection<T>
    // #region FixedSizeIndexedCollection<T>
    /**
     * A well-known symbol used to define the `FixedSizeIndexedCollection#[FixedSizeIndexedCollection.setAt]` method.
     */
    FixedSizeIndexedCollection.setAt = Symbol.for("@esfx/collection-core!FixedSizeIndexedCollection.setAt");
    // #endregion FixedSizeIndexedCollection<T>
    FixedSizeIndexedCollection.name = "FixedSizeIndexedCollection";
    /**
     * Tests whether a value supports the minimal representation of a `FixedSizeIndexedCollection`.
     */
    function hasInstance(value) {
        return ReadonlyIndexedCollection.hasInstance(value)
            && FixedSizeIndexedCollection.setAt in value;
    }
    FixedSizeIndexedCollection.hasInstance = hasInstance;
})(FixedSizeIndexedCollection = exports.FixedSizeIndexedCollection || (exports.FixedSizeIndexedCollection = {}));
var IndexedCollection;
(function (IndexedCollection) {
    // #region ReadonlyCollection<T>
    IndexedCollection.size = ReadonlyCollection.size;
    IndexedCollection.has = ReadonlyCollection.has;
    // #endregion ReadonlyCollection<T>
    // #region ReadonlyIndexedCollection<T>
    IndexedCollection.indexOf = ReadonlyIndexedCollection.indexOf;
    IndexedCollection.getAt = ReadonlyIndexedCollection.getAt;
    // #endregion ReadonlyIndexedCollection<T>
    // #region FixedSizeIndexedCollection<T>
    IndexedCollection.setAt = FixedSizeIndexedCollection.setAt;
    // #endregion FixedSizeIndexedCollection<T>
    // #region Collection<T>
    IndexedCollection.add = Collection.add;
    IndexedCollection.delete = Collection.delete;
    IndexedCollection.clear = Collection.clear;
    // #endregion Collection<T>
    // #region IndexedCollection<T>
    /**
     * A well-known symbol used to define the `IndexedCollection#[IndexedCollection.insertAt]` method.
     */
    IndexedCollection.insertAt = Symbol.for("@esfx/collection-core!IndexedCollection.insertAt");
    /**
     * A well-known symbol used to define the `IndexedCollection#[IndexedCollection.removeAt]` method.
     */
    IndexedCollection.removeAt = Symbol.for("@esfx/collection-core!IndexedCollection.removeAt");
    // #endregion IndexedCollection<T>
    IndexedCollection.name = "IndexedCollection";
    /**
     * Tests whether a value supports the minimal representation of an `IndexedCollection`.
     */
    function hasInstance(value) {
        return FixedSizeIndexedCollection.hasInstance(value)
            && IndexedCollection.insertAt in value
            && IndexedCollection.removeAt in value;
    }
    IndexedCollection.hasInstance = hasInstance;
})(IndexedCollection = exports.IndexedCollection || (exports.IndexedCollection = {}));
var ReadonlyKeyedContainer;
(function (ReadonlyKeyedContainer) {
    // #region ReadonlyKeyedContainer<K, V>
    /**
     * A well-known symbol used to define the `ReadonlyKeyedContainer#[ReadonlyKeyedContainer.has]` method.
     */
    ReadonlyKeyedContainer.has = Symbol.for("@esfx/collection-core!ReadonlyKeyedContainer.has");
    /**
     * A well-known symbol used to define the `ReadonlyKeyedContainer#[ReadonlyKeyedContainer.get]` method.
     */
    ReadonlyKeyedContainer.get = Symbol.for("@esfx/collection-core!ReadonlyKeyedContainer.get");
    // #endregion ReadonlyKeyedContainer<K, V>
    ReadonlyKeyedContainer.name = "ReadonlyKeyedContainer";
    /**
     * Tests whether a value supports the minimal representation of a `ReadonlyKeyedCollection`.
     */
    function hasInstance(value) {
        return (typeof value === "object" && value !== null || typeof value === "function") && ReadonlyKeyedContainer.has in value
            && ReadonlyKeyedContainer.get in value;
    }
    ReadonlyKeyedContainer.hasInstance = hasInstance;
})(ReadonlyKeyedContainer = exports.ReadonlyKeyedContainer || (exports.ReadonlyKeyedContainer = {}));
var KeyedContainer;
(function (KeyedContainer) {
    // #region ReadonlyKeyedContainer<K, V>
    KeyedContainer.has = ReadonlyKeyedContainer.has;
    KeyedContainer.get = ReadonlyKeyedContainer.get;
    // #endregion ReadonlyKeyedContainer<K, V>
    // #region KeyedContainer<K, V>
    /**
     * A well-known symbol used to define the `KeyedContainer#[KeyedContainer.set]` method.
     */
    KeyedContainer.set = Symbol.for("@esfx/collection-core!KeyedCollection.set");
    KeyedContainer.delete = Symbol.for("@esfx/collection-core!KeyedCollection.delete");
    // #endregion KeyedContainer<K, V>
    KeyedContainer.name = "KeyedContainer";
    /**
     * Tests whether a value supports the minimal representation of a `KeyedContainer`.
     */
    function hasInstance(value) {
        return ReadonlyKeyedContainer.hasInstance(value)
            && KeyedContainer.set in value
            && KeyedContainer.delete in value;
    }
    KeyedContainer.hasInstance = hasInstance;
})(KeyedContainer = exports.KeyedContainer || (exports.KeyedContainer = {}));
var ReadonlyKeyedCollection;
(function (ReadonlyKeyedCollection) {
    // #region ReadonlyKeyedContainer<K, V>
    ReadonlyKeyedCollection.has = ReadonlyKeyedContainer.has;
    ReadonlyKeyedCollection.get = ReadonlyKeyedContainer.get;
    // #endregion ReadonlyKeyedContainer<K, V>
    // #region ReadonlyKeyedCollection<K, V>
    /**
     * A well-known symbol used to define the `ReadonlyKeyedCollection#[ReadonlyKeyedCollection.size]` property.
     */
    ReadonlyKeyedCollection.size = Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.size");
    /**
     * A well-known symbol used to define the `ReadonlyKeyedCollection#[ReadonlyKeyedCollection.keys]` method.
     */
    ReadonlyKeyedCollection.keys = Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.keys");
    /**
     * A well-known symbol used to define the `ReadonlyKeyedCollection#[ReadonlyKeyedCollection.values]` method.
     */
    ReadonlyKeyedCollection.values = Symbol.for("@esfx/collection-core!ReadonlyKeyedCollection.values");
    // #endregion ReadonlyKeyedCollection<K, V>
    ReadonlyKeyedCollection.name = "ReadonlyKeyedCollection";
    /**
     * Tests whether a value supports the minimal representation of a `ReadonlyKeyedCollection`.
     */
    function hasInstance(value) {
        return (typeof value === "object" && value !== null || typeof value === "function") && Symbol.iterator in value && ReadonlyKeyedContainer.hasInstance(value)
            && ReadonlyKeyedCollection.size in value
            && ReadonlyKeyedCollection.keys in value
            && ReadonlyKeyedCollection.values in value;
    }
    ReadonlyKeyedCollection.hasInstance = hasInstance;
})(ReadonlyKeyedCollection = exports.ReadonlyKeyedCollection || (exports.ReadonlyKeyedCollection = {}));
var KeyedCollection;
(function (KeyedCollection) {
    // #region ReadonlyKeyedCollection<K, V>
    KeyedCollection.size = ReadonlyKeyedCollection.size;
    KeyedCollection.has = ReadonlyKeyedCollection.has;
    KeyedCollection.get = ReadonlyKeyedCollection.get;
    KeyedCollection.keys = ReadonlyKeyedCollection.keys;
    KeyedCollection.values = ReadonlyKeyedCollection.values;
    // #endregion ReadonlyKeyedCollection<K, V>
    // #region KeyedContainer<K, V>
    KeyedCollection.set = KeyedContainer.set;
    KeyedCollection.delete = KeyedContainer.delete;
    // #endregion KeyedContainer<K, V>
    // #region KeyedCollection<K, V>
    /**
     * A well-known symbol used to define the `KeyedCollection#[KeyedCollection.clear]` method.
     */
    KeyedCollection.clear = Symbol.for("@esfx/collection-core!KeyedCollection.clear");
    // #endregion KeyedCollection<K, V>
    KeyedCollection.name = "KeyedCollection";
    /**
     * Tests whether a value supports the minimal representation of a `KeyedCollection`.
     */
    function hasInstance(value) {
        return ReadonlyKeyedCollection.hasInstance(value)
            && KeyedContainer.hasInstance(value)
            && KeyedCollection.clear in value;
    }
    KeyedCollection.hasInstance = hasInstance;
})(KeyedCollection = exports.KeyedCollection || (exports.KeyedCollection = {}));
var ReadonlyKeyedMultiCollection;
(function (ReadonlyKeyedMultiCollection) {
    // #region ReadonlyKeyedMultiCollection<K, V>
    /**
     * A well-known symbol used to define the `ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.size]` property.
     */
    ReadonlyKeyedMultiCollection.size = Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.size");
    /**
     * A well-known symbol used to define the `ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.has]` method.
     */
    ReadonlyKeyedMultiCollection.has = Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.has");
    /**
     * A well-known symbol used to define the `ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.hasValue]` method.
     */
    ReadonlyKeyedMultiCollection.hasValue = Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.hasValue");
    /**
     * A well-known symbol used to define the `ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.get]` method.
     */
    ReadonlyKeyedMultiCollection.get = Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.get");
    /**
     * A well-known symbol used to define the `ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.keys]` method.
     */
    ReadonlyKeyedMultiCollection.keys = Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.keys");
    /**
     * A well-known symbol used to define the `ReadonlyKeyedMultiCollection#[ReadonlyKeyedMultiCollection.values]` method.
     */
    ReadonlyKeyedMultiCollection.values = Symbol.for("@esfx/collection-core!ReadonlyKeyedMultiCollection.values");
    // #endregion ReadonlyKeyedMultiCollection<K, V>
    ReadonlyKeyedMultiCollection.name = "ReadonlyKeyedMultiCollection";
    /**
     * Tests whether a value supports the minimal representation of a `ReadonlyKeyedMultiCollection`.
     */
    function hasInstance(value) {
        return (typeof value === "object" && value !== null || typeof value === "function") && Symbol.iterator in value && ReadonlyKeyedMultiCollection.size in value
            && ReadonlyKeyedMultiCollection.has in value
            && ReadonlyKeyedMultiCollection.hasValue in value
            && ReadonlyKeyedMultiCollection.get in value
            && ReadonlyKeyedMultiCollection.keys in value
            && ReadonlyKeyedMultiCollection.values in value;
    }
    ReadonlyKeyedMultiCollection.hasInstance = hasInstance;
})(ReadonlyKeyedMultiCollection = exports.ReadonlyKeyedMultiCollection || (exports.ReadonlyKeyedMultiCollection = {}));
var KeyedMultiCollection;
(function (KeyedMultiCollection) {
    // #region ReadonlyKeyedMultiCollection<K, V>
    KeyedMultiCollection.size = ReadonlyKeyedMultiCollection.size;
    KeyedMultiCollection.has = ReadonlyKeyedMultiCollection.has;
    KeyedMultiCollection.hasValue = ReadonlyKeyedMultiCollection.hasValue;
    KeyedMultiCollection.get = ReadonlyKeyedMultiCollection.get;
    KeyedMultiCollection.keys = ReadonlyKeyedMultiCollection.keys;
    KeyedMultiCollection.values = ReadonlyKeyedMultiCollection.values;
    // #endregion ReadonlyKeyedMultiCollection<K, V>
    // #region KeyedMultiCollection<K, V>
    /**
     * A well-known symbol used to define the `KeyedMultiCollection#[KeyedMultiCollection.add]` method.
     */
    KeyedMultiCollection.add = Symbol.for("@esfx/collection-core!KeyedMultiCollection.add");
    KeyedMultiCollection.delete = Symbol.for("@esfx/collection-core!KeyedMultiCollection.delete");
    /**
     * A well-known symbol used to define the `KeyedMultiCollection#[KeyedMultiCollection.deleteValue]` method.
     */
    KeyedMultiCollection.deleteValue = Symbol.for("@esfx/collection-core!KeyedMultiCollection.deleteValue");
    /**
     * A well-known symbol used to define the `KeyedMultiCollection#[KeyedMultiCollection.clear]` method.
     */
    KeyedMultiCollection.clear = Symbol.for("@esfx/collection-core!KeyedMultiCollection.clear");
    // #endregion KeyedMultiCollection<K, V>
    KeyedMultiCollection.name = "KeyedMultiCollection";
    /**
     * Tests whether a value supports the minimal representation of a `KeyedMultiCollection`.
     */
    function hasInstance(value) {
        return ReadonlyKeyedMultiCollection.hasInstance(value)
            && KeyedMultiCollection.add in value
            && KeyedMultiCollection.delete in value
            && KeyedMultiCollection.deleteValue in value
            && KeyedMultiCollection.clear in value;
    }
    KeyedMultiCollection.hasInstance = hasInstance;
})(KeyedMultiCollection = exports.KeyedMultiCollection || (exports.KeyedMultiCollection = {}));
//# sourceMappingURL=index.js.map