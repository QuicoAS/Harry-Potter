/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   LinkedList is derived from the implementation of LinkedList in
   Promise Extensions for Javascript: https://github.com/rbuckton/prex

   Promise Extensions is licensed under the Apache 2.0 License:

   Promise Extensions for JavaScript
   Copyright (c) Microsoft Corporation

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
import { Collection, ReadonlyCollection } from "@esfx/collection-core";
import { Equaler, EqualityComparison } from "@esfx/equatable";
/**
 * A node in a [doubly-linked list](https://en.wikipedia.org/wiki/Doubly_linked_list).
 */
export declare class LinkedListNode<T> {
    private _list;
    private _previous;
    private _next;
    /**
     * The value for the node.
     */
    value: T;
    constructor(value: T);
    /**
     * Gets the list associated with this node. If the node is not attached to a {@link LinkedList}, then this returns
     * `undefined`.
     */
    get list(): LinkedList<T> | undefined;
    /**
     * Gets the {@link LinkedListNode} preceding this node in the list. If this is the first node in the list, or the
     * node is not attached to a {@link LinkedList}, then this returns `undefined`.
     */
    get previous(): LinkedListNode<T> | undefined;
    /**
     * Gets the {@link LinkedListNode} following this node in the list. If this is the last node in the list, or the
     * node is not attached to a {@link LinkedList}, then this returns `undefined`.
     */
    get next(): LinkedListNode<T> | undefined;
    /**
     * Removes this node from its associated list.
     * @returns `true` if the node was successfully removed from the list; otherwise, `false`.
     */
    detachSelf(): boolean;
    [Symbol.toStringTag]: string;
}
/**
 * A collection representing a [doubly-linked list](https://en.wikipedia.org/wiki/Doubly_linked_list).
 */
export declare class LinkedList<T> implements Collection<T> {
    private _size;
    private _head;
    private _equaler;
    constructor(equaler?: EqualityComparison<T> | Equaler<T>);
    constructor(iterable?: Iterable<T>, equaler?: EqualityComparison<T> | Equaler<T>);
    /**
     * Gets the {@link Equaler} used for equality comparisons in this list.
     */
    get equaler(): Equaler<T>;
    /**
     * Gets the first node in the list. If the list is empty, this returns `undefined`.
     */
    get first(): LinkedListNode<T> | undefined;
    /**
     * Gets the last node in the list. If the list is empty, this returns `undefined`.
     */
    get last(): LinkedListNode<T> | undefined;
    /**
     * Gets the number of elements in the list.
     */
    get size(): number;
    [Symbol.iterator](): IterableIterator<T>;
    values(): IterableIterator<T>;
    nodes(): IterableIterator<LinkedListNode<T>>;
    /**
     * Returns an iterator that removes each node from the list before yielding the node's value.
     */
    drain(): IterableIterator<T>;
    /**
     * Finds the first node in the list with the provided value.
     * @param value The value to find.
     * @param fromNode When provided, starts looking for `value` starting at this node.
     */
    nodeOf(value: T, fromNode?: LinkedListNode<T> | null): LinkedListNode<T> | undefined;
    /**
     * Finds the last node in the list with the provided value, starting from the end of the list.
     * @param value The value to find.
     * @param fromNode When provided, starts looking for `value` starting at this node and working backwards towards the front of the list.
     */
    lastNodeOf(value: T, fromNode?: LinkedListNode<T> | null): LinkedListNode<T> | undefined;
    /**
     * Finds the first value in the list that matches the provided callback.
     * @param callback The callback used to test each value and node.
     * @param thisArg The `this` value to use when executing `callback`.
     */
    find<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): S | undefined;
    /**
     * Finds the first value in the list that matches the provided callback.
     * @param callback The callback used to test each value and node.
     * @param thisArg The `this` value to use when executing `callback`.
     */
    find(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): T | undefined;
    /**
     * Finds the last value in the list that matches the provided callback, starting from the end of the list.
     * @param callback The callback used to test each value and node.
     * @param thisArg The `this` value to use when executing `callback`.
     */
    findLast<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): S | undefined;
    /**
     * Finds the last value in the list that matches the provided callback, starting from the end of the list.
     * @param callback The callback used to test each value and node.
     * @param thisArg The `this` value to use when executing `callback`.
     */
    findLast(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): T | undefined;
    /**
     * Finds the first {@link LinkedListNode} in the list that matches the provided callback.
     * @param callback The callback used to test each value and node.
     * @param thisArg The `this` value to use when executing `callback`.
     */
    findNode<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): LinkedListNode<S> | undefined;
    /**
     * Finds the first {@link LinkedListNode} in the list that matches the provided callback.
     * @param callback The callback used to test each value and node.
     * @param thisArg The `this` value to use when executing `callback`.
     */
    findNode(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): LinkedListNode<T> | undefined;
    /**
     * Finds the last {@link LinkedListNode} in the list that matches the provided callback, starting from the end of the list.
     * @param callback The callback used to test each value and node.
     * @param thisArg The `this` value to use when executing `callback`.
     */
    findLastNode<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): LinkedListNode<S> | undefined;
    /**
     * Finds the last {@link LinkedListNode} in the list that matches the provided callback, starting from the end of the list.
     * @param callback The callback used to test each value and node.
     * @param thisArg The `this` value to use when executing `callback`.
     */
    findLastNode(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): LinkedListNode<T> | undefined;
    /**
     * Returns a value indicating whether `value` exists within the list.
     */
    has(value: T): boolean;
    /**
     * Inserts a new {@link LinkedListNode} containing `value` into the list before the provided `node`.
     * If `node` is either `null` or `undefined`, the new node is inserted at the beginning of the list.
     * @param node The node before which `value` will be inserted.
     * @param value The value to insert.
     * @returns The new {@link LinkedListNode} for `value`.
     */
    insertBefore(node: LinkedListNode<T> | null | undefined, value: T): LinkedListNode<T>;
    /**
     * Inserts `newNode` into the list before the provided `node`. If `node` is either `null` or `undefined`, `newNode`
     * is inserted at the beginning of the list.
     * @param node The node before which `newNode` will be inserted.
     * @param newNode The new node to insert.
     */
    insertNodeBefore(node: LinkedListNode<T> | null | undefined, newNode: LinkedListNode<T>): void;
    /**
     * Inserts a new {@link LinkedListNode} containing `value` into the list after the provided `node`.
     * If `node` is either `null` or `undefined`, the new node is inserted at the end of the list.
     * @param node The node after which `value` will be inserted.
     * @param value The value to insert.
     * @returns The new {@link LinkedListNode} for `value`.
     */
    insertAfter(node: LinkedListNode<T> | null | undefined, value: T): LinkedListNode<T>;
    /**
     * Inserts `newNode` into the list after the provided `node`. If `node` is either `null` or `undefined`, `newNode`
     * is inserted at the end of the list.
     * @param node The node after which `newNode` will be inserted.
     * @param newNode The new node to insert.
     */
    insertNodeAfter(node: LinkedListNode<T> | null | undefined, newNode: LinkedListNode<T>): void;
    /**
     * Inserts a new {@link LinkedListNode} containing `value` at the end of the list.
     * @param value The value to insert.
     * @returns The new {@link LinkedListNode} for `value`.
     */
    push(value: T): LinkedListNode<T>;
    /**
     * Inserts `newNode` at the end of the list.
     * @param newNode The node to insert.
     */
    pushNode(newNode: LinkedListNode<T>): void;
    /**
     * Removes the last node from the list and returns its value. If the list is empty, `undefined` is returned instead.
     */
    pop(): T | undefined;
    /**
     * Removes the last node from the list and returns it. If the lsit is empty, `undefined` is returned instead.
     */
    popNode(): LinkedListNode<T> | undefined;
    /**
     * Removes the first node from the list and returns its value. If the list is empty, `undefined` is returned instead.
     */
    shift(): T | undefined;
    /**
     * Removes the first node from the list and returns it. If the list is empty, `undefined` is returned instead.
     */
    shiftNode(): LinkedListNode<T> | undefined;
    /**
     * Inserts a new {@link LinkedListNode} containing `value` at the beginning of the list.
     * @param value The value to insert.
     * @returns The new {@link LinkedListNode} for `value`.
     */
    unshift(value: T): LinkedListNode<T>;
    /**
     * Inserts `newNode` at the beginning of the list.
     * @param newNode The node to insert.
     */
    unshiftNode(newNode: LinkedListNode<T>): void;
    /**
     * Finds the first node in the list containing `value`, removes it from the list, and returns it. If a node
     * containing `value` could not be found, `undefined` is returned instead.
     */
    delete(value: T): LinkedListNode<T> | undefined;
    /**
     * Removes the provided node from the list.
     * @returns `true` if the node was successfully removed from the list; otherwise, `false`.
     */
    deleteNode(node: LinkedListNode<T> | null | undefined): boolean;
    /**
     * Removes all nodes from the list matching the supplied `predicate`.
     * @param predicate A callback function used to test each value and node in the list.
     * @param thisArg The `this` value to use when executing `predicate`.
     */
    deleteAll(predicate: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): number;
    /**
     * Removes all nodes from the list.
     */
    clear(): void;
    forEach(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => void, thisArg?: any): void;
    /**
     * Calls the provided `callback` function on each element of the list, and returns a new {@link LinkedList} that contains the results.
     * @param callback The callback to call for each value and node.
     * @param thisArg The `this` value to use when executing `callback`.
     */
    map<U>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => U, thisArg?: any): LinkedList<U>;
    /**
     * Returns the elements of a the list that meet the condition specified in the provided `callback` function.
     * @param callback The `callback` to call for each value and node.
     * @param thisArg The `this` value to use when executing `callback`.
     */
    filter<S extends T>(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => value is S, thisArg?: any): LinkedList<S>;
    /**
     * Returns the elements of a the list that meet the condition specified in the provided `callback` function.
     * @param callback The `callback` to call for each value and node.
     * @param thisArg The `this` value to use when executing `callback`.
     */
    filter(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): LinkedList<T>;
    /**
     * Calls the specified `callback` function for all the nodes in the list. The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     * @param callback A function that accepts up to four arguments. The reduce method calls the callback function one time for each element in the list.
     */
    reduce(callback: (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T): T;
    /**
     * Calls the specified `callback` function for all the nodes in the list. The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     * @param callback A function that accepts up to four arguments. The reduce method calls the callback function one time for each element in the list.
     * @param initialValue  If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the `callback` function provides this value as an argument instead of a list value.
     */
    reduce(callback: (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T, initialValue: T): T;
    /**
     * Calls the specified `callback` function for all the nodes in the list. The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     * @param callback A function that accepts up to four arguments. The reduce method calls the callback function one time for each element in the list.
     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the `callback` function provides this value as an argument instead of a list value.
     */
    reduce<U>(callback: (previousValue: U, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => U, initialValue: U): U;
    /**
     * Calls the specified `callback` function for all the nodes in the list, in reverse. The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     * @param callback A function that accepts up to four arguments. The reduce method calls the callback function one time for each element in the list.
     */
    reduceRight(callback: (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T): T;
    /**
     * Calls the specified `callback` function for all the nodes in the list, in reverse. The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     * @param callback A function that accepts up to four arguments. The reduce method calls the callback function one time for each element in the list.
     * @param initialValue  If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the `callback` function provides this value as an argument instead of a list value.
     */
    reduceRight(callback: (previousValue: T, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => T, initialValue: T): T;
    /**
     * Calls the specified `callback` function for all the nodes in the list, in reverse. The return value of the callback function is the accumulated result,
     * and is provided as an argument in the next call to the callback function.
     * @param callback A function that accepts up to four arguments. The reduce method calls the callback function one time for each element in the list.
     * @param initialValue  If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the `callback` function provides this value as an argument instead of a list value.
     */
    reduceRight<U>(callback: (previousValue: U, value: T, node: LinkedListNode<T>, list: LinkedList<T>) => U, initialValue: U): U;
    some(callback?: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): boolean;
    every(callback: (value: T, node: LinkedListNode<T>, list: LinkedList<T>) => boolean, thisArg?: any): boolean;
    private _deleteNode;
    private _insertNode;
    [Symbol.toStringTag]: string;
    get [ReadonlyCollection.size](): number;
    [ReadonlyCollection.has](value: T): boolean;
    [Collection.add](value: T): void;
    [Collection.delete](value: T): boolean;
    [Collection.clear](): void;
}
//# sourceMappingURL=index.d.ts.map