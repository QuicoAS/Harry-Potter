"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   THIRD PARTY LICENSE NOTICE:

   LinkedList is derived from the implementation of LinkedList in
   Promise Extensions for Javascript: https://github.com/rbuckton/prex

   Promise Extensions is licensed under the Apache 2.0 License:

   Promise Extensions for JavaScript
   Copyright (c) Microsoft Corporation

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkedList = exports.LinkedListNode = void 0;
const collection_core_1 = require("@esfx/collection-core");
const equatable_1 = require("@esfx/equatable");
let setList;
let getPrevious;
let setPrevious;
let getNext;
let setNext;
/**
 * A node in a [doubly-linked list](https://en.wikipedia.org/wiki/Doubly_linked_list).
 */
class LinkedListNode {
    constructor(value) {
        this._list = undefined;
        this._previous = undefined;
        this._next = undefined;
        this.value = value;
    }
    /**
     * Gets the list associated with this node. If the node is not attached to a {@link LinkedList}, then this returns
     * `undefined`.
     */
    get list() {
        return this._list;
    }
    /**
     * Gets the {@link LinkedListNode} preceding this node in the list. If this is the first node in the list, or the
     * node is not attached to a {@link LinkedList}, then this returns `undefined`.
     */
    get previous() {
        if (this._previous && this._list && this !== this._list.first) {
            return this._previous;
        }
        return undefined;
    }
    /**
     * Gets the {@link LinkedListNode} following this node in the list. If this is the last node in the list, or the
     * node is not attached to a {@link LinkedList}, then this returns `undefined`.
     */
    get next() {
        if (this._next && this._list && this._next !== this._list.first) {
            return this._next;
        }
        return undefined;
    }
    /**
     * Removes this node from its associated list.
     * @returns `true` if the node was successfully removed from the list; otherwise, `false`.
     */
    detachSelf() {
        return this._list ? this._list.deleteNode(this) : false;
    }
}
exports.LinkedListNode = LinkedListNode;
_a = LinkedListNode;
(() => {
    setList = (node, list) => { node._list = list; };
    getPrevious = node => node._previous;
    setPrevious = (node, previous) => { node._previous = previous; };
    getNext = node => node._next;
    setNext = (node, next) => { node._next = next; };
    Object.defineProperty(_a.prototype, Symbol.toStringTag, { configurable: true, writable: true, value: "LinkedListNode" });
})();
/**
 * A collection representing a [doubly-linked list](https://en.wikipedia.org/wiki/Doubly_linked_list).
 */
class LinkedList {
    constructor(...args) {
        this._size = 0;
        this._head = undefined;
        let iterable;
        let equaler;
        if (args.length > 0) {
            const arg0 = args[0];
            if (arg0 === undefined || arg0 !== undefined && arg0 !== null && Symbol.iterator in Object(arg0)) {
                iterable = arg0;
                if (args.length > 1)
                    equaler = args[1];
            }
            else {
                equaler = arg0;
            }
        }
        equaler !== null && equaler !== void 0 ? equaler : (equaler = equatable_1.Equaler.defaultEqualer);
        this._equaler = typeof equaler === "function" ? equatable_1.Equaler.create(equaler) : equaler;
        if (iterable) {
            for (const value of iterable) {
                this.push(value);
            }
        }
    }
    /**
     * Gets the {@link Equaler} used for equality comparisons in this list.
     */
    get equaler() {
        return this._equaler;
    }
    /**
     * Gets the first node in the list. If the list is empty, this returns `undefined`.
     */
    get first() {
        return this._head;
    }
    /**
     * Gets the last node in the list. If the list is empty, this returns `undefined`.
     */
    get last() {
        if (this._head) {
            return getPrevious(this._head);
        }
        return undefined;
    }
    /**
     * Gets the number of elements in the list.
     */
    get size() {
        return this._size;
    }
    [Symbol.iterator]() {
        return this.values();
    }
    *values() {
        for (const node of this.nodes()) {
            yield node.value;
        }
    }
    *nodes() {
        let node;
        let next = this.first;
        while (next !== undefined) {
            node = next;
            next = node.next;
            yield node;
        }
    }
    /**
     * Returns an iterator that removes each node from the list before yielding the node's value.
     */
    *drain() {
        for (const node of this.nodes()) {
            this.deleteNode(node);
            yield node.value;
        }
    }
    /**
     * Finds the first node in the list with the provided value.
     * @param value The value to find.
     * @param fromNode When provided, starts looking for `value` starting at this node.
     */
    nodeOf(value, fromNode) {
        if (!(fromNode === null || fromNode === undefined) && !(fromNode instanceof LinkedListNode))
            throw new TypeError("LinkedListNode expected: fromNode");
        if (!(fromNode === null || fromNode === undefined) && fromNode.list !== this)
            throw new TypeError("Wrong list.");
        for (let node = fromNode !== null && fromNode !== void 0 ? fromNode : this.first; node; node = node.next) {
            if (this._equaler.equals(node.value, value)) {
                return node;
            }
        }
        return undefined;
    }
    /**
     * Finds the last node in the list with the provided value, starting from the end of the list.
     * @param value The value to find.
     * @param fromNode When provided, starts looking for `value` starting at this node and working backwards towards the front of the list.
     */
    lastNodeOf(value, fromNode) {
        if (!(fromNode === null || fromNode === undefined) && !(fromNode instanceof LinkedListNode))
            throw new TypeError("LinkedListNode expected: fromNode");
        if (!(fromNode === null || fromNode === undefined) && fromNode.list !== this)
            throw new TypeError("Wrong list.");
        for (let node = fromNode !== null && fromNode !== void 0 ? fromNode : this.last; node; node = node.previous) {
            if (this._equaler.equals(node.value, value)) {
                return node;
            }
        }
        return undefined;
    }
    find(callback, thisArg) {
        if (!(typeof callback === "function"))
            throw new TypeError("Function expected: callback");
        let node;
        let next = this.first;
        while (next !== undefined) {
            node = next;
            next = node.next;
            const value = node.value;
            if (callback.call(thisArg, value, node, this))
                return value;
        }
        return undefined;
    }
    findLast(callback, thisArg) {
        if (!(typeof callback === "function"))
            throw new TypeError("Function expected: callback");
        let node;
        let prev = this.last;
        while (prev !== undefined) {
            node = prev;
            prev = node.previous;
            const value = node.value;
            if (callback.call(thisArg, value, node, this))
                return value;
        }
        return undefined;
    }
    findNode(callback, thisArg) {
        if (!(typeof callback === "function"))
            throw new TypeError("Function expected: callback");
        let node;
        let next = this.first;
        while (next !== undefined) {
            node = next;
            next = node.next;
            if (callback.call(thisArg, node.value, node, this))
                return node;
        }
        return undefined;
    }
    findLastNode(callback, thisArg) {
        if (!(typeof callback === "function"))
            throw new TypeError("Function expected: callback");
        let node;
        let prev = this.last;
        while (prev !== undefined) {
            node = prev;
            prev = node.previous;
            if (callback.call(thisArg, node.value, node, this))
                return node;
        }
        return undefined;
    }
    /**
     * Returns a value indicating whether `value` exists within the list.
     */
    has(value) {
        return this.nodeOf(value) !== undefined;
    }
    /**
     * Inserts a new {@link LinkedListNode} containing `value` into the list before the provided `node`.
     * If `node` is either `null` or `undefined`, the new node is inserted at the beginning of the list.
     * @param node The node before which `value` will be inserted.
     * @param value The value to insert.
     * @returns The new {@link LinkedListNode} for `value`.
     */
    insertBefore(node, value) {
        if (!(node === null || node === undefined) && !(node instanceof LinkedListNode))
            throw new TypeError("LinkedListNode expected: node");
        if (!(node === null || node === undefined) && node.list !== this)
            throw new TypeError("Wrong list.");
        return this._insertNode(node !== null && node !== void 0 ? node : undefined, new LinkedListNode(value), 0 /* before */);
    }
    /**
     * Inserts `newNode` into the list before the provided `node`. If `node` is either `null` or `undefined`, `newNode`
     * is inserted at the beginning of the list.
     * @param node The node before which `newNode` will be inserted.
     * @param newNode The new node to insert.
     */
    insertNodeBefore(node, newNode) {
        if (!(node === null || node === undefined) && !(node instanceof LinkedListNode))
            throw new TypeError("LinkedListNode expected: node");
        if (!(node === null || node === undefined) && node.list !== this)
            throw new TypeError("Wrong list.");
        if (!(newNode instanceof LinkedListNode))
            throw new TypeError("LinkedListNode expected: newNode");
        if (newNode.list)
            throw new Error("Node is already attached to a list.");
        this._insertNode(node || undefined, newNode, 0 /* before */);
    }
    /**
     * Inserts a new {@link LinkedListNode} containing `value` into the list after the provided `node`.
     * If `node` is either `null` or `undefined`, the new node is inserted at the end of the list.
     * @param node The node after which `value` will be inserted.
     * @param value The value to insert.
     * @returns The new {@link LinkedListNode} for `value`.
     */
    insertAfter(node, value) {
        if (!(node === null || node === undefined) && !(node instanceof LinkedListNode))
            throw new TypeError("LinkedListNode expected: node");
        if (!(node === null || node === undefined) && node.list !== this)
            throw new TypeError("Wrong list.");
        return this._insertNode(node || undefined, new LinkedListNode(value), 1 /* after */);
    }
    /**
     * Inserts `newNode` into the list after the provided `node`. If `node` is either `null` or `undefined`, `newNode`
     * is inserted at the end of the list.
     * @param node The node after which `newNode` will be inserted.
     * @param newNode The new node to insert.
     */
    insertNodeAfter(node, newNode) {
        if (!(node === null || node === undefined) && !(node instanceof LinkedListNode))
            throw new TypeError("LinkedListNode expected: node");
        if (!(node === null || node === undefined) && node.list !== this)
            throw new TypeError("Wrong list.");
        if (!(newNode instanceof LinkedListNode))
            throw new TypeError("LinkedListNode expected: newNode");
        if (newNode.list)
            throw new Error("Node is already attached to a list.");
        this._insertNode(node || undefined, newNode, 1 /* after */);
    }
    /**
     * Inserts a new {@link LinkedListNode} containing `value` at the end of the list.
     * @param value The value to insert.
     * @returns The new {@link LinkedListNode} for `value`.
     */
    push(value) {
        return this._insertNode(undefined, new LinkedListNode(value), 1 /* after */);
    }
    /**
     * Inserts `newNode` at the end of the list.
     * @param newNode The node to insert.
     */
    pushNode(newNode) {
        if (!(newNode instanceof LinkedListNode))
            throw new TypeError("LinkedListNode expected: newNode");
        if (newNode.list)
            throw new Error("Node is already attached to a list.");
        this._insertNode(undefined, newNode, 1 /* after */);
    }
    /**
     * Removes the last node from the list and returns its value. If the list is empty, `undefined` is returned instead.
     */
    pop() {
        const node = this.popNode();
        return node ? node.value : undefined;
    }
    /**
     * Removes the last node from the list and returns it. If the lsit is empty, `undefined` is returned instead.
     */
    popNode() {
        const node = this.last;
        if (this.deleteNode(node)) {
            return node;
        }
    }
    /**
     * Removes the first node from the list and returns its value. If the list is empty, `undefined` is returned instead.
     */
    shift() {
        const node = this.shiftNode();
        return node ? node.value : undefined;
    }
    /**
     * Removes the first node from the list and returns it. If the list is empty, `undefined` is returned instead.
     */
    shiftNode() {
        const node = this.first;
        if (this.deleteNode(node)) {
            return node;
        }
    }
    /**
     * Inserts a new {@link LinkedListNode} containing `value` at the beginning of the list.
     * @param value The value to insert.
     * @returns The new {@link LinkedListNode} for `value`.
     */
    unshift(value) {
        return this._insertNode(undefined, new LinkedListNode(value), 0 /* before */);
    }
    /**
     * Inserts `newNode` at the beginning of the list.
     * @param newNode The node to insert.
     */
    unshiftNode(newNode) {
        if (!(newNode instanceof LinkedListNode))
            throw new TypeError("LinkedListNode expected: newNode");
        if (newNode.list)
            throw new Error("Node is already attached to a list.");
        this._insertNode(undefined, newNode, 0 /* before */);
    }
    /**
     * Finds the first node in the list containing `value`, removes it from the list, and returns it. If a node
     * containing `value` could not be found, `undefined` is returned instead.
     */
    delete(value) {
        const node = this.nodeOf(value);
        if (node && this.deleteNode(node)) {
            return node;
        }
        return undefined;
    }
    /**
     * Removes the provided node from the list.
     * @returns `true` if the node was successfully removed from the list; otherwise, `false`.
     */
    deleteNode(node) {
        if (!(node === null || node === undefined) && !(node instanceof LinkedListNode))
            throw new TypeError("LinkedListNode expected: node");
        if (!(node === null || node === undefined) && node.list !== this)
            throw new TypeError("Wrong list.");
        if (node === null || node === undefined || !node.list)
            return false;
        return this._deleteNode(node);
    }
    /**
     * Removes all nodes from the list matching the supplied `predicate`.
     * @param predicate A callback function used to test each value and node in the list.
     * @param thisArg The `this` value to use when executing `predicate`.
     */
    deleteAll(predicate, thisArg) {
        if (!(typeof predicate === "function"))
            throw new TypeError("Function expected: predicate");
        let count = 0;
        let node = this.first;
        while (node) {
            const next = node.next;
            if (predicate.call(thisArg, node.value, node, this) && node.list === this) {
                this._deleteNode(node);
                ++count;
            }
            node = next;
        }
        return count;
    }
    /**
     * Removes all nodes from the list.
     */
    clear() {
        while (this.size > 0) {
            this.deleteNode(this.last);
        }
    }
    forEach(callback, thisArg) {
        if (!(typeof callback === "function"))
            throw new TypeError("Function expected: callback");
        let node;
        let next = this.first;
        while (next !== undefined) {
            node = next;
            next = node.next;
            callback.call(thisArg, node.value, node, this);
        }
    }
    /**
     * Calls the provided `callback` function on each element of the list, and returns a new {@link LinkedList} that contains the results.
     * @param callback The callback to call for each value and node.
     * @param thisArg The `this` value to use when executing `callback`.
     */
    map(callback, thisArg) {
        if (!(typeof callback === "function"))
            throw new TypeError("Function expected: callback");
        const mappedList = new LinkedList();
        let node;
        let next = this.first;
        while (next !== undefined) {
            node = next;
            next = node.next;
            const mappedValue = callback.call(thisArg, node.value, node, this);
            mappedList.push(mappedValue);
        }
        return mappedList;
    }
    filter(callback, thisArg) {
        if (!(typeof callback === "function"))
            throw new TypeError("Function expected: callback");
        const mappedList = new LinkedList(this.equaler);
        let node;
        let next = this.first;
        while (next !== undefined) {
            node = next;
            next = node.next;
            const value = node.value;
            if (callback.call(thisArg, value, node, this)) {
                mappedList.push(value);
            }
        }
        return mappedList;
    }
    reduce(callback, initialValue) {
        if (!(typeof callback === "function"))
            throw new TypeError("Function expected: callback");
        let hasInitialValue = arguments.length > 1;
        let result = initialValue;
        let node;
        let next = this.first;
        while (next !== undefined) {
            node = next;
            next = node.next;
            const value = node.value;
            if (!hasInitialValue) {
                result = value;
                hasInitialValue = true;
            }
            else {
                result = callback(result, value, node, this);
            }
        }
        return result;
    }
    reduceRight(callback, initialValue) {
        if (!(typeof callback === "function"))
            throw new TypeError("Function expected: callback");
        let hasInitialValue = arguments.length > 1;
        let result = initialValue;
        let node;
        let prev = this.last;
        while (prev !== undefined) {
            node = prev;
            const value = node.value;
            if (!hasInitialValue) {
                result = value;
                hasInitialValue = true;
            }
            else {
                result = callback(result, value, node, this);
            }
            prev = node.previous;
        }
        return result;
    }
    some(callback, thisArg) {
        if (!(callback === undefined) && !(typeof callback === "function"))
            throw new TypeError("Function expected: callback");
        let node;
        let next = this.first;
        while (next !== undefined) {
            node = next;
            next = node.next;
            if (!callback || callback.call(thisArg, node.value, node, this))
                return true;
        }
        return false;
    }
    every(callback, thisArg) {
        if (!(typeof callback === "function"))
            throw new TypeError("Function expected: callback");
        let hasMatch = false;
        let node;
        let next = this.first;
        while (next !== undefined) {
            node = next;
            next = node.next;
            if (!callback.call(thisArg, node.value, node, this))
                return false;
            hasMatch = true;
        }
        return hasMatch;
    }
    _deleteNode(node) {
        if (getNext(node) === node) {
            this._head = undefined;
        }
        else {
            setPrevious(getNext(node), getPrevious(node));
            setNext(getPrevious(node), getNext(node));
            if (this._head === node) {
                this._head = getNext(node);
            }
        }
        setList(node, undefined);
        setPrevious(node, undefined);
        setNext(node, undefined);
        this._size--;
        return true;
    }
    _insertNode(adjacentNode, newNode, position) {
        setList(newNode, this);
        if (this._head === undefined) {
            setNext(newNode, newNode);
            setPrevious(newNode, newNode);
            this._head = newNode;
        }
        else {
            switch (position) {
                case 0 /* before */:
                    if (adjacentNode === undefined) {
                        adjacentNode = this._head;
                        this._head = newNode;
                    }
                    else if (adjacentNode === this._head) {
                        this._head = newNode;
                    }
                    setNext(newNode, adjacentNode);
                    setPrevious(newNode, getPrevious(adjacentNode));
                    setNext(getPrevious(adjacentNode), newNode);
                    setPrevious(adjacentNode, newNode);
                    break;
                case 1 /* after */:
                    if (adjacentNode === undefined) {
                        adjacentNode = getPrevious(this._head);
                    }
                    setPrevious(newNode, adjacentNode);
                    setNext(newNode, getNext(adjacentNode));
                    setPrevious(getNext(adjacentNode), newNode);
                    setNext(adjacentNode, newNode);
                    break;
            }
        }
        this._size++;
        return newNode;
    }
    // ReadonlyCollection<T>
    get [collection_core_1.ReadonlyCollection.size]() { return this.size; }
    [collection_core_1.ReadonlyCollection.has](value) { return this.has(value); }
    // Collection<T>
    [collection_core_1.Collection.add](value) { this.push(value); }
    [collection_core_1.Collection.delete](value) { return !!this.delete(value); }
    [collection_core_1.Collection.clear]() { this.clear(); }
}
exports.LinkedList = LinkedList;
_b = LinkedList;
(() => {
    Object.defineProperty(_b.prototype, Symbol.toStringTag, { configurable: true, writable: true, value: "LinkedList" });
})();
//# sourceMappingURL=index.js.map