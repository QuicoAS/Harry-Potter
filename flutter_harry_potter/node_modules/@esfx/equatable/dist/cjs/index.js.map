{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts","../../../../internal/guards/dist/cjs/index.js"],"names":[],"mappings":"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","sourcesContent":["/*!\r\n   Copyright 2019 Ron Buckton\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n*/\r\n\r\nimport /*#__INLINE__*/ { isMissing, isNumber } from \"@esfx/internal-guards\";\r\nimport { hashUnknown } from './internal/hashUnknown.js';\r\n\r\n/**\r\n * Represents a value that can compare its equality with another value.\r\n */\r\nexport interface Equatable {\r\n    /**\r\n     * Determines whether this value is equal to another value.\r\n     * @param other The other value.\r\n     * @returns `true` if this value is equal to `other`; otherwise, `false`.\r\n     */\r\n    [Equatable.equals](other: unknown): boolean;\r\n\r\n    /**\r\n     * Compute a hash code for an value.\r\n     * @returns The numeric hash-code for the value.\r\n     */\r\n    [Equatable.hash](): number;\r\n}\r\n\r\n/**\r\n * Utility functions and well-known symbols used to define an `Equatable`.\r\n */\r\nexport namespace Equatable {\r\n    // #region Equatable\r\n    /**\r\n     * A well-known symbol used to define an equality test method on a value.\r\n     */\r\n    export const equals = Symbol.for(\"@esfx/equatable:Equatable.equals\");\r\n\r\n    /**\r\n     * A well-known symbol used to define a hashing method on a value.\r\n     */\r\n    export const hash = Symbol.for(\"@esfx/equatable:Equatable.hash\");\r\n    // #endregion Equatable\r\n\r\n    export const name = \"Equatable\";\r\n\r\n    /**\r\n     * Determines whether a value is Equatable.\r\n     * @param value The value to test.\r\n     * @returns `true` if the value is an Equatable; otherwise, `false`.\r\n     */\r\n    export function hasInstance(value: unknown): value is Equatable {\r\n        let obj: object;\r\n        return !isMissing(value)\r\n            && equals in (obj = Object(value))\r\n            && hash in obj;\r\n    }\r\n\r\n    Object.defineProperty(Equatable, Symbol.hasInstance, { configurable: true, writable: true, value: hasInstance });\r\n}\r\n\r\n/**\r\n * Represents a value that can compare itself relationally with another value.\r\n */\r\nexport interface Comparable {\r\n    /**\r\n     * Compares this value with another value, returning a value indicating one of the following conditions:\r\n     *\r\n     * - A negative value indicates this value is lesser.\r\n     *\r\n     * - A positive value indicates this value is greater.\r\n     *\r\n     * - A zero value indicates this value is the same.\r\n     *\r\n     * @param other The other value to compare against.\r\n     * @returns A number indicating the relational comparison result.\r\n     */\r\n    [Comparable.compareTo](other: unknown): number;\r\n}\r\n\r\n/**\r\n * Utility functions and well-known symbols used to define a `Comparable`.\r\n */\r\nexport namespace Comparable {\r\n    // #region Comparable\r\n    /**\r\n     * A well-known symbol used to define a relational comparison method on a value.\r\n     */\r\n    export const compareTo = Symbol.for(\"@esfx/equatable:Comparable.compareTo\");\r\n    // #endregion Comparable\r\n\r\n    export const name = \"Comparable\";\r\n\r\n    /**\r\n     * Determines whether a value is Comparable.\r\n     * @param value The value to test.\r\n     * @returns `true` if the value is a Comparable; otherwise, `false`.\r\n     */\r\n    export function hasInstance(value: unknown): value is Comparable {\r\n        return !isMissing(value)\r\n            && compareTo in Object(value);\r\n    }\r\n\r\n    Object.defineProperty(Comparable, Symbol.hasInstance, { configurable: true, writable: true, value: hasInstance });\r\n}\r\n\r\n/**\r\n * Represents a value that can compare its structural equality with another value.\r\n */\r\nexport interface StructuralEquatable {\r\n    /**\r\n     * Determines whether this value is structurally equal to another value using the supplied `Equaler`.\r\n     * @param other The other value.\r\n     * @param equaler The `Equaler` to use to test equality.\r\n     * @returns `true` if this value is structurally equal to `other`; otherwise, `false`.\r\n     */\r\n    [StructuralEquatable.structuralEquals](other: unknown, equaler: Equaler<unknown>): boolean;\r\n\r\n    /**\r\n     * Compute a structural hash code for a value using the supplied `Equaler`.\r\n     * @param equaler The `Equaler` to use to generate hashes for values in the structure.\r\n     * @returns The numeric hash-code of the structure.\r\n     */\r\n    [StructuralEquatable.structuralHash](equaler: Equaler<unknown>): number;\r\n}\r\n\r\n/**\r\n * Utility functions and well-known symbols used to define a `StructuralEquatable`.\r\n */\r\nexport namespace StructuralEquatable {\r\n    // #region StructuralEquatable\r\n    /**\r\n     * A well-known symbol used to define a structural equality test method on a value.\r\n     */\r\n    export const structuralEquals = Symbol.for(\"@esfx/equatable:StructualEquatable.structuralEquals\");\r\n\r\n    /**\r\n     * A well-known symbol used to define a structural hashing method on a value.\r\n     */\r\n    export const structuralHash = Symbol.for(\"@esfx/equatable:StructuralEquatable.structuralHash\");\r\n    // #endregion StructuralEquatable\r\n\r\n    export const name = \"StructuralEquatable\";\r\n\r\n    /**\r\n     * Determines whether a value is StructuralEquatable.\r\n     * @param value The value to test.\r\n     * @returns `true` if the value is StructuralEquatable; otherwise, `false`.\r\n     */\r\n    export function hasInstance(value: unknown): value is StructuralEquatable {\r\n        let obj: object;\r\n        return !isMissing(value)\r\n            && structuralEquals in (obj = Object(value))\r\n            && structuralHash in obj;\r\n    }\r\n\r\n    Object.defineProperty(StructuralEquatable, Symbol.hasInstance, { configurable: true, writable: true, value: hasInstance });\r\n}\r\n\r\n/**\r\n * Represents a value that can compare its structure relationally with another value.\r\n */\r\nexport interface StructuralComparable {\r\n    /**\r\n     * Compares the structure of this value with another value using the supplied comparer,\r\n     * returning a value indicating one of the following conditions:\r\n     * - A negative value indicates this value is lesser.\r\n     * - A positive value indicates this value is greater.\r\n     * - A zero value indicates this value is the same.\r\n     * @param other The other value to compare against.\r\n     * @param comparer The compare to use to compare values in the structure.\r\n     * @returns A numeric value indicating the relational comparison result.\r\n     */\r\n    [StructuralComparable.structuralCompareTo](other: unknown, comparer: Comparer<unknown>): number;\r\n}\r\n\r\n/**\r\n * Utility functions and well-known symbols used to define a `StructuralComparable`.\r\n */\r\nexport namespace StructuralComparable {\r\n    // #region StructuralComparable\r\n    /**\r\n     * A well-known symbol used to define a structural comparison method on a value.\r\n     */\r\n    export const structuralCompareTo = Symbol.for(\"@esfx/equatable:StructuralComparable.structuralCompareTo\");\r\n    // #endregion StructuralComparable\r\n\r\n    export const name = \"StructuralComparable\";\r\n\r\n    /**\r\n     * Determines whether a value is StructuralComparable.\r\n     * @param value The value to test.\r\n     * @returns `true` if the value is StructuralComparable; otherwise, `false`.\r\n     */\r\n    export function hasInstance(value: unknown): value is StructuralComparable {\r\n        return !isMissing(value)\r\n            && structuralCompareTo in Object(value);\r\n    }\r\n\r\n    Object.defineProperty(StructuralComparable, Symbol.hasInstance, { configurable: true, writable: true, value: hasInstance });\r\n}\r\n\r\n/**\r\n * Describes a function that can be used to compare the equality of two values.\r\n * @typeParam T The type of value that can be compared.\r\n */\r\nexport type EqualityComparison<T> = (x: T, y: T) => boolean;\r\n\r\n/**\r\n * Describes a function that can be used to compute a hash code for a value.\r\n * @typeParam T The type of value that can be hashed.\r\n */\r\nexport type HashGenerator<T> = (x: T) => number;\r\n\r\n/**\r\n * Represents an object that can be used to compare the equality of two values.\r\n * @typeParam T The type of each value that can be compared.\r\n */\r\nexport interface Equaler<T> {\r\n    /**\r\n     * Tests whether two values are equal to each other.\r\n     * @param x The first value.\r\n     * @param y The second value.\r\n     * @returns `true` if the values are equal; otherwise, `false`.\r\n     */\r\n    equals(x: T, y: T): boolean;\r\n\r\n    /**\r\n     * Generates a hash code for a value.\r\n     * @param x The value to hash.\r\n     * @returns The numeric hash-code for the value.\r\n     */\r\n    hash(x: T): number;\r\n}\r\n\r\n/**\r\n * Provides various implementations of `Equaler`.\r\n */\r\nexport namespace Equaler {\r\n    const equalerPrototype = Object.defineProperty({}, Symbol.toStringTag, { configurable: true, value: \"Equaler\" });\r\n\r\n    /**\r\n     * Gets the default `Equaler`.\r\n     */\r\n    export const defaultEqualer: Equaler<unknown> = create(\r\n        (x, y) => Equatable.hasInstance(x) ? x[Equatable.equals](y) :\r\n            Equatable.hasInstance(y) ? y[Equatable.equals](x) :\r\n            Object.is(x, y),\r\n        (x) => Equatable.hasInstance(x) ? x[Equatable.hash]() :\r\n            rawHash(x)\r\n    );\r\n\r\n    /**\r\n     * Gets a default `Equaler` that supports `StructuralEquatable` values.\r\n     */\r\n    export const structuralEqualer: Equaler<unknown> = create(\r\n        (x, y) => StructuralEquatable.hasInstance(x) ? x[StructuralEquatable.structuralEquals](y, structuralEqualer) :\r\n            StructuralEquatable.hasInstance(y) ? y[StructuralEquatable.structuralEquals](x, structuralEqualer) :\r\n            defaultEqualer.equals(x, y),\r\n        (x) => StructuralEquatable.hasInstance(x) ? x[StructuralEquatable.structuralHash](structuralEqualer) :\r\n            defaultEqualer.hash(x));\r\n\r\n    /**\r\n     * An `Equaler` that compares array values rather than the arrays themselves.\r\n     */\r\n    export const tupleEqualer: Equaler<readonly unknown[]> = create(\r\n        (x, y) => {\r\n            if (!isMissing(x) && !Array.isArray(x) ||\r\n                !isMissing(y) && !Array.isArray(y)) {\r\n                throw new TypeError(\"Array expected\");\r\n            }\r\n            if (x === y) {\r\n                return true;\r\n            }\r\n            if (!x || !y || x.length !== y.length) {\r\n                return false;\r\n            }\r\n            for (let i = 0; i < x.length; i++) {\r\n                if (!Equaler.defaultEqualer.equals(x[i], y[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n        (x) => {\r\n            if (isMissing(x)) {\r\n                return 0;\r\n            }\r\n            if (!Array.isArray(x)) {\r\n                throw new TypeError(\"Array expected\");\r\n            }\r\n            let hc = 0;\r\n            for (const item of x) {\r\n                hc = combineHashes(hc, Equaler.defaultEqualer.hash(item));\r\n            }\r\n            return hc;\r\n        });\r\n\r\n    /**\r\n     * An `Equaler` that compares array values that may be `StructuralEquatable` rather than the arrays themselves.\r\n     */\r\n    export const tupleStructuralEqualer: Equaler<readonly unknown[]> = create(\r\n        (x, y) => {\r\n            if (!isMissing(x) && !Array.isArray(x) ||\r\n                !isMissing(y) && !Array.isArray(y)) {\r\n                throw new TypeError(\"Array expected\");\r\n            }\r\n            if (x === y) {\r\n                return true;\r\n            }\r\n            if (!x || !y || x.length !== y.length) {\r\n                return false;\r\n            }\r\n            for (let i = 0; i < x.length; i++) {\r\n                if (!Equaler.structuralEqualer.equals(x[i], y[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n        (x) => {\r\n            if (isMissing(x)) {\r\n                return 0;\r\n            }\r\n            if (!Array.isArray(x)) {\r\n                throw new TypeError(\"Array expected\");\r\n            }\r\n            let hc = 0;\r\n            for (const item of x) {\r\n                hc = combineHashes(hc, Equaler.structuralEqualer.hash(item));\r\n            }\r\n            return hc;\r\n        });\r\n\r\n    /**\r\n     * Creates an `Equaler` from a comparison function and an optional hash generator.\r\n     * @typeParam T The type of value that can be compared.\r\n     * @param equalityComparison A callback used to compare the equality of two values.\r\n     * @param hashGenerator A callback used to compute a numeric hash-code for a value.\r\n     * @returns An Equaler for the provided callbacks.\r\n     */\r\n    export function create<T>(equalityComparison: EqualityComparison<T>, hashGenerator: HashGenerator<T> = defaultEqualer.hash): Equaler<T> {\r\n        return Object.setPrototypeOf({ equals: equalityComparison, hash: hashGenerator }, equalerPrototype);\r\n    }\r\n\r\n    /**\r\n     * Combines two hash codes.\r\n     * @param x The first hash code.\r\n     * @param y The second hash code.\r\n     * @param rotate The number of bits (between 0 and 31) to left-rotate the first hash code before XOR'ing it with the second (default 7).\r\n     */\r\n    export function combineHashes(x: number, y: number, rotate: number = 7) {\r\n        if (!isNumber(x)) throw new TypeError(\"Integer expected: x\");\r\n        if (!isNumber(y)) throw new TypeError(\"Integer expected: y\");\r\n        if (!isNumber(rotate)) throw new TypeError(\"Integer expected: rotate\");\r\n        if (isNaN(x) || !isFinite(x)) throw new RangeError(\"Argument must be a finite number value: x\");\r\n        if (isNaN(y) || !isFinite(y)) throw new RangeError(\"Argument must be a finite number value: y\");\r\n        if (isNaN(rotate) || !isFinite(rotate)) throw new RangeError(\"Argument must be a finite number value: rotate\");\r\n        while (rotate < 0) rotate += 32;\r\n        while (rotate >= 32) rotate -= 32;\r\n        return ((x << rotate) | (x >>> (32 - rotate))) ^ y;\r\n    }\r\n\r\n    export function hasInstance(value: unknown): value is Equaler<unknown> {\r\n        return typeof value === \"object\"\r\n            && value !== null\r\n            && typeof (value as Equaler<unknown>).equals === \"function\"\r\n            && typeof (value as Equaler<unknown>).hash === \"function\";\r\n    }\r\n\r\n    Object.defineProperty(Equaler, Symbol.hasInstance, { configurable: true, writable: true, value: hasInstance });\r\n}\r\n\r\nexport import defaultEqualer = Equaler.defaultEqualer;\r\nexport import structuralEqualer = Equaler.structuralEqualer;\r\nexport import tupleEqualer = Equaler.tupleEqualer;\r\nexport import tupleStructuralEqualer = Equaler.tupleEqualer;\r\nexport import combineHashes = Equaler.combineHashes;\r\n\r\n/**\r\n * Describes a function that can be used to compare the relational equality of two values, returning a\r\n * value indicating one of the following conditions:\r\n * - A negative value indicates `x` is lesser than `y`.\r\n * - A positive value indicates `x` is greater than `y`.\r\n * - A zero value indicates `x` and `y` are equivalent.\r\n * @typeParam T The type of value that can be compared.\r\n */\r\nexport type Comparison<T> = (x: T, y: T) => number;\r\n\r\n/**\r\n * Represents an object that can be used to perform a relational comparison between two values.\r\n * @typeParam T The type of value that can be compared.\r\n */\r\nexport interface Comparer<T> {\r\n    /**\r\n     * Compares two values, returning a value indicating one of the following conditions:\r\n     * - A negative value indicates `x` is lesser than `y`.\r\n     * - A positive value indicates `x` is greater than `y`.\r\n     * - A zero value indicates `x` and `y` are equivalent.\r\n     * @param x The first value to compare.\r\n     * @param y The second value to compare.\r\n     * @returns A number indicating the relational comparison result.\r\n     */\r\n    compare(x: T, y: T): number;\r\n}\r\n\r\n/**\r\n * Provides various implementations of `Comparer`.\r\n */\r\nexport namespace Comparer {\r\n    const comparerProtototype = Object.defineProperty({}, Symbol.toStringTag, { configurable: true, value: \"Comparer\" });\r\n\r\n    /**\r\n     * The default `Comparer`.\r\n     */\r\n    export const defaultComparer: Comparer<unknown> = create((x, y) => \r\n        Comparable.hasInstance(x) ? x[Comparable.compareTo](y) :\r\n        Comparable.hasInstance(y) ? -y[Comparable.compareTo](x) :\r\n        (x as any) < (y as any) ? -1 :\r\n        (x as any) > (y as any) ? 1 :\r\n        0);\r\n\r\n    /**\r\n     * A default `Comparer` that supports `StructuralComparable` values.\r\n     */\r\n    export const structuralComparer: Comparer<unknown> = create((x, y) => \r\n        StructuralComparable.hasInstance(x) ? x[StructuralComparable.structuralCompareTo](y, structuralComparer) :\r\n        StructuralComparable.hasInstance(y) ? -y[StructuralComparable.structuralCompareTo](x, structuralComparer) :\r\n        defaultComparer.compare(x, y));\r\n\r\n    /**\r\n     * A default `Comparer` that compares array values rather than the arrays themselves.\r\n     */\r\n    export const tupleComparer: Comparer<readonly unknown[]> = create((x, y) => {\r\n        if (!isMissing(x) && !Array.isArray(x) ||\r\n            !isMissing(y) && !Array.isArray(y)) {\r\n            throw new TypeError(\"Array expected\");\r\n        }\r\n        let r: number;\r\n        if (r = defaultComparer.compare(x.length, y.length)) {\r\n            return r;\r\n        }\r\n        for (let i = 0; i < x.length; i++) {\r\n            if (r = defaultComparer.compare(x[i], y[i])) {\r\n                return r;\r\n            }\r\n        }\r\n        return 0;\r\n    });\r\n\r\n    /**\r\n     * A default `Comparer` that compares array values that may be `StructuralComparable` rather than the arrays themselves.\r\n     */\r\n    export const tupleStructuralComparer: Comparer<readonly unknown[]> = create((x, y) => {\r\n        if (!isMissing(x) && !Array.isArray(x) ||\r\n            !isMissing(y) && !Array.isArray(y)) {\r\n            throw new TypeError(\"Array expected\");\r\n        }\r\n        let r: number;\r\n        if (r = defaultComparer.compare(x.length, y.length)) {\r\n            return r;\r\n        }\r\n        for (let i = 0; i < x.length; i++) {\r\n            if (r = structuralComparer.compare(x[i], y[i])) {\r\n                return r;\r\n            }\r\n        }\r\n        return 0;\r\n    });\r\n\r\n    /**\r\n     * Creates a `Comparer` from a comparison function.\r\n     * @typeParam T The type of value that can be compared.\r\n     * @param comparison A Comparison function used to create a Comparer.\r\n     * @returns The Comparer for the provided comparison function.\r\n     */\r\n    export function create<T>(comparison: Comparison<T>): Comparer<T> {\r\n        return Object.setPrototypeOf({ compare: comparison }, comparerProtototype);\r\n    }\r\n\r\n    export function hasInstance(value: unknown): value is Comparer<unknown> {\r\n        return typeof value === \"object\"\r\n            && value !== null\r\n            && typeof (value as Comparer<unknown>).compare === \"function\";\r\n    }\r\n\r\n    Object.defineProperty(Comparer, Symbol.hasInstance, { configurable: true, writable: true, value: hasInstance });\r\n}\r\n\r\nexport import defaultComparer = Comparer.defaultComparer;\r\nexport import structuralComparer = Comparer.structuralComparer;\r\nexport import tupleComparer = Comparer.tupleComparer;\r\nexport import tupleStructuralComparer = Comparer.tupleStructuralComparer;\r\n\r\n/**\r\n * Gets the raw hashcode for a value. This bypasses any `[Equatable.hash]` properties on an object.\r\n * @param value Any value.\r\n * @returns The hashcode for the value.\r\n */\r\nexport function rawHash(value: unknown): number {\r\n    return hashUnknown(value);\r\n}\r\n","\"use strict\";\n/*\n   Copyright 2019 Ron Buckton\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isPrimitive = exports.isPropertyKey = exports.isString = exports.isBoolean = exports.isPositiveInteger = exports.isInteger = exports.isPositiveNonZeroFiniteNumber = exports.isPositiveFiniteNumber = exports.isNumber = exports.isIterator = exports.isAsyncIterableObject = exports.isAsyncIterable = exports.isIterableObject = exports.isIterable = exports.isPresent = exports.isMissing = exports.isDefined = exports.isUndefined = exports.isInstance = exports.isObject = exports.isFunctionOrUndefined = exports.isFunction = void 0;\n/*@internal*/\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\nexports.isFunction = isFunction;\n/*@internal*/\nfunction isFunctionOrUndefined(value) {\n    return typeof value === \"function\" || value === undefined;\n}\nexports.isFunctionOrUndefined = isFunctionOrUndefined;\n/*@internal*/\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null\n        || typeof value === \"function\";\n}\nexports.isObject = isObject;\n/*@internal*/\nfunction isInstance(value, ctor) {\n    return !isMissing(value) && value instanceof ctor;\n}\nexports.isInstance = isInstance;\n/*@internal*/\nfunction isUndefined(value) {\n    return value === undefined;\n}\nexports.isUndefined = isUndefined;\n/*@internal*/\nfunction isDefined(value) {\n    return value === undefined;\n}\nexports.isDefined = isDefined;\n/*@internal*/\nfunction isMissing(value) {\n    return value === null\n        || value === undefined;\n}\nexports.isMissing = isMissing;\n/*@internal*/\nfunction isPresent(value) {\n    return value !== null\n        && value !== undefined;\n}\nexports.isPresent = isPresent;\n/*@internal*/\nfunction isIterable(value) {\n    return value !== undefined\n        && value !== null\n        && Symbol.iterator in Object(value);\n}\nexports.isIterable = isIterable;\n/*@internal*/\nfunction isIterableObject(value) {\n    return isObject(value) && Symbol.iterator in value;\n}\nexports.isIterableObject = isIterableObject;\n/*@internal*/\nfunction isAsyncIterable(value) {\n    return value !== undefined\n        && value !== null\n        && Symbol.asyncIterator in Object(value);\n}\nexports.isAsyncIterable = isAsyncIterable;\n/*@internal*/\nfunction isAsyncIterableObject(value) {\n    return isObject(value) && Symbol.asyncIterator in value;\n}\nexports.isAsyncIterableObject = isAsyncIterableObject;\n/** @internal */\nfunction isIterator(value) {\n    return isObject(value)\n        && isFunction(value.next)\n        && isFunctionOrUndefined(value.throw)\n        && isFunctionOrUndefined(value.return)\n        && isFunctionOrUndefined(value[Symbol.iterator]);\n}\nexports.isIterator = isIterator;\n;\n;\n;\n;\n/*@internal*/\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\nexports.isNumber = isNumber;\n/*@internal*/\nfunction isPositiveFiniteNumber(value) {\n    return isFinite(value) && value >= 0;\n}\nexports.isPositiveFiniteNumber = isPositiveFiniteNumber;\n/*@internal*/\nfunction isPositiveNonZeroFiniteNumber(value) {\n    return isFinite(value) && value > 0;\n}\nexports.isPositiveNonZeroFiniteNumber = isPositiveNonZeroFiniteNumber;\n/*@internal*/\nfunction isInteger(value) {\n    return Object.is(value, value | 0);\n}\nexports.isInteger = isInteger;\n/*@internal*/\nfunction isPositiveInteger(value) {\n    return isInteger(value) && value >= 0;\n}\nexports.isPositiveInteger = isPositiveInteger;\n/*@internal*/\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\nexports.isBoolean = isBoolean;\n/*@internal*/\nfunction isString(value) {\n    return typeof value === \"string\";\n}\nexports.isString = isString;\n/*@internal*/\nfunction isPropertyKey(value) {\n    return typeof value === \"string\"\n        || typeof value === \"symbol\"\n        || typeof value === \"number\";\n}\nexports.isPropertyKey = isPropertyKey;\n/*@internal*/\nfunction isPrimitive(value) {\n    return typeof value !== \"function\"\n        && (typeof value !== \"object\" || value === null);\n}\nexports.isPrimitive = isPrimitive;\n//# sourceMappingURL=index.js.map"]}