"use strict";
/*!
   Copyright 2019 Ron Buckton

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.rawHash = exports.tupleStructuralComparer = exports.tupleComparer = exports.structuralComparer = exports.defaultComparer = exports.Comparer = exports.combineHashes = exports.tupleStructuralEqualer = exports.tupleEqualer = exports.structuralEqualer = exports.defaultEqualer = exports.Equaler = exports.StructuralComparable = exports.StructuralEquatable = exports.Comparable = exports.Equatable = void 0;
const hashUnknown_js_1 = require("./internal/hashUnknown.js");
/**
 * Utility functions and well-known symbols used to define an `Equatable`.
 */
var Equatable;
(function (Equatable) {
    // #region Equatable
    /**
     * A well-known symbol used to define an equality test method on a value.
     */
    Equatable.equals = Symbol.for("@esfx/equatable:Equatable.equals");
    /**
     * A well-known symbol used to define a hashing method on a value.
     */
    Equatable.hash = Symbol.for("@esfx/equatable:Equatable.hash");
    // #endregion Equatable
    Equatable.name = "Equatable";
    /**
     * Determines whether a value is Equatable.
     * @param value The value to test.
     * @returns `true` if the value is an Equatable; otherwise, `false`.
     */
    function hasInstance(value) {
        let obj;
        return !(value === null || value === undefined)
            && Equatable.equals in (obj = Object(value))
            && Equatable.hash in obj;
    }
    Equatable.hasInstance = hasInstance;
    Object.defineProperty(Equatable, Symbol.hasInstance, { configurable: true, writable: true, value: hasInstance });
})(Equatable = exports.Equatable || (exports.Equatable = {}));
/**
 * Utility functions and well-known symbols used to define a `Comparable`.
 */
var Comparable;
(function (Comparable) {
    // #region Comparable
    /**
     * A well-known symbol used to define a relational comparison method on a value.
     */
    Comparable.compareTo = Symbol.for("@esfx/equatable:Comparable.compareTo");
    // #endregion Comparable
    Comparable.name = "Comparable";
    /**
     * Determines whether a value is Comparable.
     * @param value The value to test.
     * @returns `true` if the value is a Comparable; otherwise, `false`.
     */
    function hasInstance(value) {
        return !(value === null || value === undefined)
            && Comparable.compareTo in Object(value);
    }
    Comparable.hasInstance = hasInstance;
    Object.defineProperty(Comparable, Symbol.hasInstance, { configurable: true, writable: true, value: hasInstance });
})(Comparable = exports.Comparable || (exports.Comparable = {}));
/**
 * Utility functions and well-known symbols used to define a `StructuralEquatable`.
 */
var StructuralEquatable;
(function (StructuralEquatable) {
    // #region StructuralEquatable
    /**
     * A well-known symbol used to define a structural equality test method on a value.
     */
    StructuralEquatable.structuralEquals = Symbol.for("@esfx/equatable:StructualEquatable.structuralEquals");
    /**
     * A well-known symbol used to define a structural hashing method on a value.
     */
    StructuralEquatable.structuralHash = Symbol.for("@esfx/equatable:StructuralEquatable.structuralHash");
    // #endregion StructuralEquatable
    StructuralEquatable.name = "StructuralEquatable";
    /**
     * Determines whether a value is StructuralEquatable.
     * @param value The value to test.
     * @returns `true` if the value is StructuralEquatable; otherwise, `false`.
     */
    function hasInstance(value) {
        let obj;
        return !(value === null || value === undefined)
            && StructuralEquatable.structuralEquals in (obj = Object(value))
            && StructuralEquatable.structuralHash in obj;
    }
    StructuralEquatable.hasInstance = hasInstance;
    Object.defineProperty(StructuralEquatable, Symbol.hasInstance, { configurable: true, writable: true, value: hasInstance });
})(StructuralEquatable = exports.StructuralEquatable || (exports.StructuralEquatable = {}));
/**
 * Utility functions and well-known symbols used to define a `StructuralComparable`.
 */
var StructuralComparable;
(function (StructuralComparable) {
    // #region StructuralComparable
    /**
     * A well-known symbol used to define a structural comparison method on a value.
     */
    StructuralComparable.structuralCompareTo = Symbol.for("@esfx/equatable:StructuralComparable.structuralCompareTo");
    // #endregion StructuralComparable
    StructuralComparable.name = "StructuralComparable";
    /**
     * Determines whether a value is StructuralComparable.
     * @param value The value to test.
     * @returns `true` if the value is StructuralComparable; otherwise, `false`.
     */
    function hasInstance(value) {
        return !(value === null || value === undefined)
            && StructuralComparable.structuralCompareTo in Object(value);
    }
    StructuralComparable.hasInstance = hasInstance;
    Object.defineProperty(StructuralComparable, Symbol.hasInstance, { configurable: true, writable: true, value: hasInstance });
})(StructuralComparable = exports.StructuralComparable || (exports.StructuralComparable = {}));
/**
 * Provides various implementations of `Equaler`.
 */
var Equaler;
(function (Equaler) {
    const equalerPrototype = Object.defineProperty({}, Symbol.toStringTag, { configurable: true, value: "Equaler" });
    /**
     * Gets the default `Equaler`.
     */
    Equaler.defaultEqualer = create((x, y) => Equatable.hasInstance(x) ? x[Equatable.equals](y) :
        Equatable.hasInstance(y) ? y[Equatable.equals](x) :
            Object.is(x, y), (x) => Equatable.hasInstance(x) ? x[Equatable.hash]() :
        rawHash(x));
    /**
     * Gets a default `Equaler` that supports `StructuralEquatable` values.
     */
    Equaler.structuralEqualer = create((x, y) => StructuralEquatable.hasInstance(x) ? x[StructuralEquatable.structuralEquals](y, Equaler.structuralEqualer) :
        StructuralEquatable.hasInstance(y) ? y[StructuralEquatable.structuralEquals](x, Equaler.structuralEqualer) :
            Equaler.defaultEqualer.equals(x, y), (x) => StructuralEquatable.hasInstance(x) ? x[StructuralEquatable.structuralHash](Equaler.structuralEqualer) :
        Equaler.defaultEqualer.hash(x));
    /**
     * An `Equaler` that compares array values rather than the arrays themselves.
     */
    Equaler.tupleEqualer = create((x, y) => {
        if (!(x === null || x === undefined) && !Array.isArray(x) ||
            !(y === null || y === undefined) && !Array.isArray(y)) {
            throw new TypeError("Array expected");
        }
        if (x === y) {
            return true;
        }
        if (!x || !y || x.length !== y.length) {
            return false;
        }
        for (let i = 0; i < x.length; i++) {
            if (!Equaler.defaultEqualer.equals(x[i], y[i])) {
                return false;
            }
        }
        return true;
    }, (x) => {
        if (x === null || x === undefined) {
            return 0;
        }
        if (!Array.isArray(x)) {
            throw new TypeError("Array expected");
        }
        let hc = 0;
        for (const item of x) {
            hc = combineHashes(hc, Equaler.defaultEqualer.hash(item));
        }
        return hc;
    });
    /**
     * An `Equaler` that compares array values that may be `StructuralEquatable` rather than the arrays themselves.
     */
    Equaler.tupleStructuralEqualer = create((x, y) => {
        if (!(x === null || x === undefined) && !Array.isArray(x) ||
            !(y === null || y === undefined) && !Array.isArray(y)) {
            throw new TypeError("Array expected");
        }
        if (x === y) {
            return true;
        }
        if (!x || !y || x.length !== y.length) {
            return false;
        }
        for (let i = 0; i < x.length; i++) {
            if (!Equaler.structuralEqualer.equals(x[i], y[i])) {
                return false;
            }
        }
        return true;
    }, (x) => {
        if (x === null || x === undefined) {
            return 0;
        }
        if (!Array.isArray(x)) {
            throw new TypeError("Array expected");
        }
        let hc = 0;
        for (const item of x) {
            hc = combineHashes(hc, Equaler.structuralEqualer.hash(item));
        }
        return hc;
    });
    /**
     * Creates an `Equaler` from a comparison function and an optional hash generator.
     * @typeParam T The type of value that can be compared.
     * @param equalityComparison A callback used to compare the equality of two values.
     * @param hashGenerator A callback used to compute a numeric hash-code for a value.
     * @returns An Equaler for the provided callbacks.
     */
    function create(equalityComparison, hashGenerator = Equaler.defaultEqualer.hash) {
        return Object.setPrototypeOf({ equals: equalityComparison, hash: hashGenerator }, equalerPrototype);
    }
    Equaler.create = create;
    /**
     * Combines two hash codes.
     * @param x The first hash code.
     * @param y The second hash code.
     * @param rotate The number of bits (between 0 and 31) to left-rotate the first hash code before XOR'ing it with the second (default 7).
     */
    function combineHashes(x, y, rotate = 7) {
        if (!(typeof x === "number"))
            throw new TypeError("Integer expected: x");
        if (!(typeof y === "number"))
            throw new TypeError("Integer expected: y");
        if (!(typeof rotate === "number"))
            throw new TypeError("Integer expected: rotate");
        if (isNaN(x) || !isFinite(x))
            throw new RangeError("Argument must be a finite number value: x");
        if (isNaN(y) || !isFinite(y))
            throw new RangeError("Argument must be a finite number value: y");
        if (isNaN(rotate) || !isFinite(rotate))
            throw new RangeError("Argument must be a finite number value: rotate");
        while (rotate < 0)
            rotate += 32;
        while (rotate >= 32)
            rotate -= 32;
        return ((x << rotate) | (x >>> (32 - rotate))) ^ y;
    }
    Equaler.combineHashes = combineHashes;
    function hasInstance(value) {
        return typeof value === "object"
            && value !== null
            && typeof value.equals === "function"
            && typeof value.hash === "function";
    }
    Equaler.hasInstance = hasInstance;
    Object.defineProperty(Equaler, Symbol.hasInstance, { configurable: true, writable: true, value: hasInstance });
})(Equaler = exports.Equaler || (exports.Equaler = {}));
exports.defaultEqualer = Equaler.defaultEqualer;
exports.structuralEqualer = Equaler.structuralEqualer;
exports.tupleEqualer = Equaler.tupleEqualer;
exports.tupleStructuralEqualer = Equaler.tupleEqualer;
exports.combineHashes = Equaler.combineHashes;
/**
 * Provides various implementations of `Comparer`.
 */
var Comparer;
(function (Comparer) {
    const comparerProtototype = Object.defineProperty({}, Symbol.toStringTag, { configurable: true, value: "Comparer" });
    /**
     * The default `Comparer`.
     */
    Comparer.defaultComparer = create((x, y) => Comparable.hasInstance(x) ? x[Comparable.compareTo](y) :
        Comparable.hasInstance(y) ? -y[Comparable.compareTo](x) :
            x < y ? -1 :
                x > y ? 1 :
                    0);
    /**
     * A default `Comparer` that supports `StructuralComparable` values.
     */
    Comparer.structuralComparer = create((x, y) => StructuralComparable.hasInstance(x) ? x[StructuralComparable.structuralCompareTo](y, Comparer.structuralComparer) :
        StructuralComparable.hasInstance(y) ? -y[StructuralComparable.structuralCompareTo](x, Comparer.structuralComparer) :
            Comparer.defaultComparer.compare(x, y));
    /**
     * A default `Comparer` that compares array values rather than the arrays themselves.
     */
    Comparer.tupleComparer = create((x, y) => {
        if (!(x === null || x === undefined) && !Array.isArray(x) ||
            !(y === null || y === undefined) && !Array.isArray(y)) {
            throw new TypeError("Array expected");
        }
        let r;
        if (r = Comparer.defaultComparer.compare(x.length, y.length)) {
            return r;
        }
        for (let i = 0; i < x.length; i++) {
            if (r = Comparer.defaultComparer.compare(x[i], y[i])) {
                return r;
            }
        }
        return 0;
    });
    /**
     * A default `Comparer` that compares array values that may be `StructuralComparable` rather than the arrays themselves.
     */
    Comparer.tupleStructuralComparer = create((x, y) => {
        if (!(x === null || x === undefined) && !Array.isArray(x) ||
            !(y === null || y === undefined) && !Array.isArray(y)) {
            throw new TypeError("Array expected");
        }
        let r;
        if (r = Comparer.defaultComparer.compare(x.length, y.length)) {
            return r;
        }
        for (let i = 0; i < x.length; i++) {
            if (r = Comparer.structuralComparer.compare(x[i], y[i])) {
                return r;
            }
        }
        return 0;
    });
    /**
     * Creates a `Comparer` from a comparison function.
     * @typeParam T The type of value that can be compared.
     * @param comparison A Comparison function used to create a Comparer.
     * @returns The Comparer for the provided comparison function.
     */
    function create(comparison) {
        return Object.setPrototypeOf({ compare: comparison }, comparerProtototype);
    }
    Comparer.create = create;
    function hasInstance(value) {
        return typeof value === "object"
            && value !== null
            && typeof value.compare === "function";
    }
    Comparer.hasInstance = hasInstance;
    Object.defineProperty(Comparer, Symbol.hasInstance, { configurable: true, writable: true, value: hasInstance });
})(Comparer = exports.Comparer || (exports.Comparer = {}));
exports.defaultComparer = Comparer.defaultComparer;
exports.structuralComparer = Comparer.structuralComparer;
exports.tupleComparer = Comparer.tupleComparer;
exports.tupleStructuralComparer = Comparer.tupleStructuralComparer;
/**
 * Gets the raw hashcode for a value. This bypasses any `[Equatable.hash]` properties on an object.
 * @param value Any value.
 * @returns The hashcode for the value.
 */
function rawHash(value) {
    return (0, hashUnknown_js_1.hashUnknown)(value);
}
exports.rawHash = rawHash;
//# sourceMappingURL=index.js.map